### 13장 동시성 성능 기법
#### 병렬처리 소개
- 데이터 병렬성
  - 큰 데이터 풀에서 작동하는 단일의 대규모 작업을 더 작은 단위로 세분화하는 것
- 작업 병렬성
  - 서로 다른 작업을 여러 프로세서에 나누어 실행하는 것
  - 자바에서는 스레드와 Executor 객체를 사용하여 이를 구현할 수 있다.
- 암달의 법칙
  - T(N) = S + (1/N) * (T-S)
    - 직렬 실행이 필요한 부분을 S, 작업에 필요한 전체 시간을 T라고 한다.
    - 프로세서의 수를 N이라하면 T(N)은 프로세서 수만큼 실행된 시간이며 T-S는 동시 실행할 수 있는 부분이며 N개의 프로세스를 고르게 분배할 수 있는 경우의 계산식
  - 하지만 작업의 복잡성이 증가하게 되고, 결국 일부 순차적 처리와 통신 오버헤드가 다시 발생
- 기본적인 자바 동시성
  ```java
  public class Counter {
      private int i = 0;
      public int increment() {
          i += 1;
          return i;
      }
  }
  ```
  - 스레드는 메서드에 진입할 때마다 개별적인 평가 스택을 갖게 되며 실제 충돌할 수 있는 부분은 필드에 대한 연산이다.
    - (힙은 모든 스레드가 공유)
  - volatile
    - volatile을 사용하면 값이 항상 캐시에서 다시 읽히도록 강제되어 다른 스레드에도 모든 업데이트를 보장한다.
    - 하지만 앞서 설명한 업데이트 손실 문제는 해결하지 못한다.
  - synchronized 를 사용하여 단순한 값의 업데이트를 제어할 수 있다.
    - 하지만 동기화를 사용하면 프로그램 속도가 느려질 수 있기 때문에 코드베이스를 병렬화하려는 모든 시도에는 추가적인 복잡성의 이점이 충분히 증명될 수 있도록 성능 테스트가 뒷받침되어야 한다.
#### 자바 메모리 모델의 이해
- 공유 상태에 접근하는 모든 곳에서, 플랫폼은 자바 메모리 모델이 제시하는 보장을 준수하도록 한다.
- 강한 메모리 모델: 모든 코어가 언제나 동일한 값을 본다.
  - 메모리에 대한 쓰기 반영 방식과 동일하게 동작
  - 캐시 무효화 알림이 메모리 버스를 가득 채우게 되어, 메인 메모리와 실질적인 데이터 전송속도가 급격히 떨어진다.
- 약한 메모리 모델: 코어마다 서로 다른 값을 볼 수 있으며, 이러한 상황이 발생할 시점을 제어하는 특별한 캐시 규칙 존재
  - Java 메모리 모델
    - 선행 발생: 한 이벤트가 다른 이벤트보다 확실히 먼저 발생
    - 동기화 관계: 해당 이벤트가 객체의 메모리 보기를 주 메모리와 동기화하도록 만든다.
    - 순차 실행: 실행중인 스레드 외부에서는 명령어가 순차적으로 실행되는 것처럼 보인다.
    - 선 해제 후 획득: 한 스레드가 잠금을 해제하면 다른 스레드가 이를 획득하기 전에 반드시 해제가 완료
  - synchronized 키워드는 이를 유지
#### 동시성 라이브러리 구축
- java.util.concurrent 라이브러리는 자바에서 멀티 스레드 애플리케이션을 작성하는 작업을 훨씬 쉽게 만들어준다.
- 스레드 핫 성능을 얻는다.
  - 스레드가 대부분의 시간을 실행에 사용하고 동일한 구조에서 작업을 수행하는 다른 스레드와 경쟁하지 않은 동시성 프로파일 의미 
- 구축 범위: 잠금과 세마포어, 래치, 원자적 연산 (atomic), 실행자 (executor), 차단 큐
- 원자적 연산 또는 비교와 교환
  - AtomicInteger는 더하기, 증가, 감소와 같은 복합 연산을 제공하며 get()과 결합하여 결과 반환
  - volatile의 확장이지만, 더 유연
  - 기대하는 현재 값과 원하는 새로운 값이라는 두개의 값을 사용하여 메모리 위치(포인터)와 함께 동작
  - 원자적 연산은 잠금이 필요 없으며 교착상태에 빠질 수 없다.
- 잠금과 반복 잠금
#### 동시성 라이브러리 요약
- java.util.concurrent 락
  ```java
  lock(): 락 획득, 락을 사용할 수 있을 때까지 블로킹
  newCondition(): 락에 조건을 추가해 유연하게 사용가능
  ex. await(), signal() 등을 통해 특정 조건동안 대기
  tryLock(): 락 획득하려고 시도, 락을 사용할 수 없는 경우에도 계속 처리 진행가능
  unlock(): 락 해제
  ```
  - LockSupport
    - 스레드를 대기 또는 재개할 수 있는 메서드 제공
    - 스레드에게 permit 발급, 없으면 대기
    - 세마포어와 비슷하지만 한 가지 퍼밋만 발급
    - 퍼밋을 받지 못한 경우 잠시 파킹, 유효한 퍼밋을 받을 수 있을 때 다시 언파킹
    - while (!canProceed()) { ... LockSupport.park(this); }
- 읽기/쓰기 잠금
  - 읽기 스레드 때문에 나머지 읽기 스레드를 블로킹하느라 불필요한 시간을 허비하는 문제 발생
  - ReentrantReadWriteLock 클래스의 ReadLock, WriteLock을 제공하며 쓰기 작업에서 차단
  - 스레드가 도착한 순서대로 처리되지만 성능 저하 가능
- 세마포어
  ```
  new Semaphore(2, true): permit 2개, 공정 모드로 생성
  비공정모드: 무한정 리소스 독점 가능
  acquire(): permit 수 감소, 더 이상 permit이 없다면 블로킹
  release(): 퍼밋 반납, 대기 중인 스레드에게 퍼밋 전달
  ```
  - 풀 스레드나 DB 접속 객체 등 여러 리소스의 엑서스를 허용하는 기술 제공, 정해진 수량의 퍼밋으로 엑세스 제어
  - 뮤텍스와 비교
    - 퍼밋이 하나 뿐이라면 뮤텍스와 동등하나 뮤텍스는 뮤텍스가 걸린 스레드만 해제 가능, 세마포어는 비소유 스레드도 해제 가능하다
- 동시 컬렉션
  - ConcurrentHashMap
    - 버킷/세그먼트로 분할된 구조
    - 각 세그먼트는 자체 락킹 정책을 가질 수 있어 쓰기가 필요한 한 세그먼트만 락을 걸 수 있음
  - CopyOnWriteArrayList, CopyOnWriteArraySet
    - 데이터를 변경할 때 배킹 배열 사본 생성
    - 기존 이터레이터는 예전 배열 계속 탐색 가능
    - 예전 배열 사본의 레퍼런스가 없게 되면 가비지 수집 대상
    - 읽는 횟수가 많을 때 잘 작동
- 래치와 배리어
  - 순차적으로 진행되는 것이 이상적인 경우 래치를 쓰는 것이 좋다.
  - countdown() 호출 시 카운트 값은 1마다 감소하고, 0에 도달하면 await() 함수에 매여 있던 스레드가 모두 해제되어 처리를 재개한다.
  - 결과가 0이 되면 해당 래치는 재사용할 수 없다는 점을 주의하자

#### 실행기와 작업 추상화
#### 가상 스레드
### 14장 분산시스템 기법
#### 기본적인 분산 데이터 구조
#### 합의 프로토콜
#### 분산시스템 예제

