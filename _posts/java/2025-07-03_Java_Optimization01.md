### 1장 최적화와 성능 정의
#### 자바 성능 개요
- 자바의 초기 성능 관점은 '환경이 충분히 빠르다면, 원시 성능을 어느 정도 희생하더라도 개발자의 생산성을 높이는 것이 더 중요하다'라는 것
  - 이러한 실용성을 바탕으로 가장 눈에 띄는 특징은 관리되는 서브 시스템
  - 예를 들면 가비지 컬렉션을 통해 자동으로 메모리 관리하고 프로그래머는 메모리를 수동적으로 관리할 필요가 없다.
- 자바 성능 데이터의 특성상 통계적으로 정교한 접근이 필요하며, 단순한 기법으로는 잘못된 결과를 산출할 수 있다.

#### 성능을 위한 분류 체계
- 성능을 관측할 수 있는 지표
  - 처리량, 효율성, 지연 시간, 확장성, 수용량, 성능 저하, 활용도
- 대 부분의 성능 프로젝트에서 모든 지표를 동시에 최적화하는 것은 불가능하며 한번의 성능 반복에서는 일부 지표만 개선될 수 있으며, 이는 한번에 달성할 수 있는 최적의 범위일 수 있다.
- 처리량
  - 시스템이나 서브시스템이 수행할 수 있는 작업의 속도를 나타내는 지표로 처리된 작업 단위를 말한다.
  - 처리량 값이 의미있으려면 플랫폼의 설명이 포함되어야 한다
    - 하드웨어 사양, 운영체제 또는 소프트웨어 스택이 처리량에 중요한 영향, 단일 서버인지 클러스터인지도 고려해야 한다.
- 지연 시간
  - 시작에서 끝까지 걸리는 시간으로 정의되며, 단일 거래를 처리하고 결과를 확인하는 데 걸리는 시간
  - 작업 부하에 따라 다를 수 있으며, 작업 부하가 증가함에 따라 지연 시간을 나타내는 그래프를 생성
- 수용량
  - 시스템이 보유한 병렬 처리 작업량을 의미, 시스템에서 동시에 진행할 수 있는 작업 단위의 수를 나타낸다.
  - 수용량과 처리량은 밀접한 관련이 있으며 부하가 증가함에 따라 처리량에 영향을 미칠 수 있다.
- 활용도
  - 시스템 리소스의 효율적인 사용을 달성하는 것
    - 이상적으로 CPU는 작업 단위를 처리하는 데 사용하며 유휴 상태로 남거나 운영 체제 작업을 처리하는 데 시간을 보내지 않아야 한다.
  - CPU, 네트워크, 메모리, I/O 서브시스템과 같은 다른 자원 유형도 클라우드 네이티브 애플리케이션에서 관리할 중요한 자원이 된다.
- 효율성
  - 처리량을 사용된 자원으로 나누면 시스템의 전체 효율성을 측정할 수 있다.
- 확장성
  - 자원을 추가할 때 처리량이 어떻게 변하는지를 기준으로 정의하는 것이 유용
  - 이상적인 것은 자원 증가에 따라 처리량이 정확히 비례하여 증가하는 것
  - 하지만 실제로는 다양한 부하 상황에서 달성하기 어렵다.
- 성능 저하
  - 부하가 증가할 때 관찰되는 지연 시간 또는 처리량에 변화가 나타난다.
  - 자원의 활용도에 따라 달라진다
     - 추가 부하로 인해 발생할 수 있는 성능 저하
- 관측 가능한 지표들 간의 상관관계
  - 여러 성능 지표의 동작은 일반적으로 어떤 방식으로든 연결되어 있다.
  - 예를들면 일반적으로 시스템의 부하가 증가하면 활용도가 변하게 된다.
    - 그러나 시스템이 낮은 활용상태라면 부하를 증가해도 활용도가 눈에 띄게 증가하지 않을 수 있다.
    - 반대로 시스템이 이미 과부하라면 부하 증가의 영향이 다른 관측 지표에 나타날 수 있다.

#### 클라우드 시스템의 성능
- 클라우드 시스템은 거의 항상 분산 시스템으로, 클러스터의 여러 노드가 공유 네트워크 자원을 통해 상호 작용한다.
- 단일 노드 시스템의 복잡성에 더해 또 다른 수준의 복잡성을 다워야 함을 의미
- 고려 사항
  - 클러스터 내에서 작업이 어떻게 분배되는가?
  - 소프트웨어의 새 버전(새 구성)을 클러스터에 어떻게 배포할 것인가?
  - 노드가 클러스터에서 이탈하면 어떻게 되는가?
  - 새 노드가 클러스터에 추가되면 어떻게 되는가?
  - 새 노드가 잘못 구성된 경우에 어떻게 되는가?
  - 새 노드가 클러스터의 나머지와 다르게 동작하면 어떻게 되는가?
  - 클러스터 자체를 제어하는 코드에 문제가 발생하면 어떻게 되는가?
  - 클러스터가 의존하는 인프라의 구성 요소가 제한된 자원일 때, 확장성에 병목이 생기면 어떻게 되는가?
- 클라우드 시스템에서는 단일 JVM 환경과 다른 두가지 중요한 측면이 존재한다.
  - 클라우드에서 배포 가능한 코드의 단위가 애플리케이션의 JVM이 아닌 컨테이너라는 점
  - 서비스에서 클라우드 제공업체를 사용하는 방식에 따라 효율성이나 활용도가 서비스 운영 비용에 직접적인 영향을 미친다.

### 2장 성능 테스트 방법론
#### 성능 테스트 종류
- 지연 테스트
  - 시작부터 끝까지의 트랜잭션 시간은 얼마나 걸리는지 확인
- 처리량 테스트
  - 현재 시스템 용량으로 몇개의 동시 거래를 처리할 수 있는 지 확인
  - 지연 테스트와 이중적인 관계가 있다.
    - 예를들면 지연테스트를 수행할 때는 지연 결과 분포를 생성하는 동안 동시 트랜잭션 수를 명확히 명시하고 제어하는 것이 중요
    - 마찬가지로 처리량 테스트를 수행할 때는 지연이 과도하게 증가하지 않도록 주의해야한다.
  - 최대 처리량을 지연 분포가 갑자기 변화하는 순간(시스템의 한계점)을 관찰해서 결정
- 스트레스 테스트
  - 시스템의 한계점은 무엇인지 확인
  - 일정한 상태의 트랜잭션 상태에 두고, 동시 트랜잭션 수를 천천히 증가시켜 시스템의 성능이 저하되기 시작하는 지점을 찾는 방식으로 진행
- 부하 테스트
  - 예상되는 비즈니스 이벤트 전에 수행되며 시스템이 특정 부하를 처리할 수 있는지 확인
- 내구성 테스트
  - 시스템을 장시간 실행했을 때 어떤 성능 이상이 발견될 수 있는 지 확인
  - 메모리 누수, 캐시 오염, 메모리 단편화 등이 포함되며 오랜 시간동안 진행된다.
- 용량 계획 테스트
  - 추가 리소스를 투입했을 때 시스템이 예상대로 확장되는 지 확인
  - 스트레스 테스트는 현재 시스템이 견딜 수 있는 한계를 찾는것이 목적이라면 용량 계획 테스트는 더 미래지향적으로 업그래이드 된 시스템이 어떤 부하를 처리할 수 있는지를 찾는 것을 목표로한다.
- 성능 저하 테스트
  - 시스템이 부분적으로 장애가 발생했을 때 어떻게 처리되는 지 확인
  - 관찰 항목으로 트랜잭션 지연 부포와 처리량이 포함

#### 모범 사례 개론
- 성능 조정 작업에서 집중할 지점을 결정할 때, 세가지 규칙을 고려하는 것이 좋다.
  - 중요한 요소가 무엇인지 파악하고, 이것을 측정하는 방법을 찾으세요.
  - 최적화하기 쉬운 것보다 중요한 것을 최적화하세요.
  - 가장 큰 영향을 미치는 요소부터 최적화를 시작하세요.
- 탐다운 성능
  - 애플리케이션 전체의 성능 동작을 분석하는 접근 방식을 일반적으로 탑다운 성능이라 한다.
  - 측정 또는 최적화할 항목을 명확히 이해하며, 이러한 성능 분석 작업이 전체 소프트웨어 개발 수명 주기에서 어떤 역할을 하는 지 파악해야 한다.
- 테스트 환경 성능
  - 가능한 프로덕션 환경과 모든 면에서 동일하게 구성되어야 한다.
  - 애플리케이션 서버 뿐만 아니라 웹 서버, 디비, MQ 등이 포함되며 부하를 처리할 수 없는 서드파티 네트워크 서비스 같은 요소는 현실적인 성능 테스트를 위해 목 서비스로 대체해야한다.
- 성능 요구사항 식별
  - 성능을 평가할 때 사용하는 지표를 특정 요소에만 한정해서는 안된다.
  - 비기능 요구사항, 최적화하려는 주요 대상이 된다.
- 소프트웨어 개발 수명 주기와 성능 테스트
  - 성능 테스트, 성능 저하 테스트를 SDLC의 중요한 부분으로 인식하고 지속적으로 수행
- 자바 특유의 문제들
  - JVM 특성상 성능 엔지니어가 추가적으로 고려해야할 몇가지 복잡한 요소가 있다.
  - JVM의 동적 자가 관리 기능에서 비롯되며 메모리 영역의 동적 튜닝과 JIT 컴파일이 대표적

### 3장 자바 가상 머신 개요
- 자바는 고수준의 설계를 바탕으로 개발자의 부담을 줄이는 것을 목표로 한다.
  - 가비지 컬렉션과 실행 최적화 같은 작업을 자바 가상 머신이 대신 처리하여 복잡성을 낮춰 주는 것이 대표적인 예
- 성능에 관심이 있는 개발자라면 JVM 기술 스택의 기본을 이해하는 것이 중요하다.

#### 인터프리팅과 클래스 로딩
- JVM은 스택 기반 인터프리터 머신
  - 하드웨어 CPU 처럼 레지스터를 사용하는 대신, 연산의 중간 결과를 저장하는 실행 스택을 사용하며 스택의 최상위 값을 기반으로 계산 수행
- 새로운 자바 프로세스가 초기화될 때, Class Loader 체인이 활용
  - 초기 로더는 부트스트랩 클래스 로더이며 핵심 자바 런타임에 필요한 클래스를 로드한다.
    - java.lang.Object, Class.ClassLoader와 같은 필수적인 클래스를 불러와 자바 시스템의 나머지 부분이 정상 동작할 수 있게 한다.
    - 부트스트랩 클래스로더는 대개 시작 성능을 향상시키기 위해 로드하는 클래스를 검증하지 않는다. 대신 부트 클래스 경로가 안전하다는 전제에 의존
  - 기본 시스템의 나머지 부분은 플랫폼 클래스 로더(ClassLoader::getPlatformClassLoader)가 로드된다.
    - 자바의 새로운 모듈 시스템에서는 자바 프로세스를 부트스트랩하는 데 필요한 코드가 훨씬 줄어들었다.
  - 마지막으로 애플리케이션 클래스 로더가 생성된다.
    - 시스템 내의 클래스는 클래스 로더와 패키지 이름을 포함한 완전히 정규화된 클래스 이름(Fully Qualified Class Name, FQCN)을 기준으로 구분된다.
- 자바 모듈 시스템이 애플리케이션 시작 방식에 변화를 주었다.
  - 자바 9부터 모든 자바 가상 머신은 모듈화되어 있으며 자바 8부터 사용되던 모놀리식 자바 가상 머신 런타임을 복원하는 호환성 모드 또는 클래식 모드는 더 이상 존재하지 않는다.
  - 애플리케이션이 모듈화되어 있지 않아도, 실행 시 반드시 모듈 그래프가 생성되며 이 그래프는 방향이 있는 비순환 그래프(DAG)여야 하며, 만약 애플리케이션의 모듈 메타 데이터가 순환을 포함하는 모듈 그래프를 생성하려고 하면 치명적인 오류가 발생한다.
  - 모듈 그래프의 여러가지 장점을 제공
    - 필요한 모듈만 로드된다.
    - 모듈 간 메타데이터의 유효성을 시작 시점에서 확이할 수 있다.
  
#### 바이트코드 실행
- 자바 소스 코드는 실행되기 전에 여러 단계의 변환 과정을 거친다.
  - 자바 컴파일러 javac를 사용하는 컴파일 과정,이는 보통 더 큰 빌드 프로세스의 일부로 호출
  - javac의 역할은 자바 코드를 .class 파일로 변환하여 바이트코드를 생성
  - javap와 같은 디스어셈블리 도구를 통해 확인할 경우, 자바 코드와 유사한 형태로 읽고 이해하기 쉽다.
- 클래스로더가 클래스를 로드할 때, 실행을 허용하기 전에 해당 클래스가 예상되는 형식에 부합하는지 검증

#### 핫스팟 소개
- 핫스팟이란 오라클 JDK와 OpenJDK의 기본 가상 머신으로 가장 널리 사용되는 자바 가상 머신 구현체를 의미
  - 이름의 유래는 자주 실행되는 코드 영역(Hot Spot)을 동적으로 찾아내어, 해당 부분에 대해 JIT(Just In Time) 컴파일러를 적용해 네이티브 코드로 변환/최적화하는 방식에서 유래
- 핫스팟 가상 머신은 자바 성능을 C나 C++와 비교할 수 있는 수준까지 올렸다.
- 다양한 기능 간의 선택과 절충이 필요한데 두가지 중요 접근 방식이 있다.
  - 하드웨어에 가까운 수준에 동작하며 '제로-코스트 추상화'와 같은 아이디어를 사용하는 방식
  - 저수준 제어보다는 개발자 생산성과 작업 완료를 더 중시하는 방식
- 제로-오버헤드 원칙은 이론적으로 훌륭하지만, 현실에서는 저수준 동작 방식을 다뤄야 하는 부담이 있다.
  - 소스 코드를 빌드 시점에 특정 플랫폼에 맞는 기계어 코드로 변환해야 하며 이를 AOT(Ahead of time compilation) 컴파일 이라 한다.
- 핫스팟 가상 머신은 프로그램의 런타임 동작을 분석하여 성능을 극대화할 수 있는 부분에 최적화를 적용하는 방식 

#### JIT 컴파일 소개
- 자바 프로그램은 실행 시 바이트코드 인터프리터에서 시작하며, 명령어는 가상화된 스택 머신에서 처리된다.
- CPU로부터 추상화된 해당 방식은 클래스 파일의 이식성이라는 장점을 제공하지만, 최적의 성능을 얻으려면 프로그램이 네이티브 기능을 최대한 활용해야 한다.
- 핫스팟 가상 머신은 해석된 바이트코드를 네이티브 코드로 컴파일하여 성능 향상
  - 네이티브 코드는 인터프리터를 거치지 않고 직접 실행
  - 핫스팟 가상 머신에서 컴파일 단위는 메서드와 루프이며 이 과정을 JIT 컴파일이라 한다.
- JIT 컴파일은 실행되는 동안 실행 빈도가 높은 코드 부분을 관찰하며 작동하여 더 정교한 최적화를 가능하게 한다.
  - 메서드가 해석되는 동안 수집된 실행 추적 정보(trace information)을 기반으로 최적화 결정을 내릴 수 있다.

#### 자바 가상 머신 메모리 관리
- 가비지 컬렉션을 통해 자동으로 관리되는 힙 메모리를 도입하여 더 많은 메모리 할당이 필요하거나 더 이상 필요하지 않은 메모리를 회수하고 재사용하는 비결정적 프로세스 수행
  - stop the world와 같은 비용이 따른다.

#### 스레딩과 자바 메모리 모델
- JVM은 멀티스레드 방식으로 동작한다. 즉, 모든 자바 프로그램이 본질적으로 멀티스레드 환경에서 실행되며 멀티스레드 환경의 복잡성을 자연스럽게 수반한다.
- 애플리케이션 스레드 == 플랫폼 스레드로의 전환, 스레드 병목 문제가 발생하면서 가상 스레드(virtual threads)가 등장

#### 출처
- 자바 최적화 2편 책 요약한 내용입니다.
