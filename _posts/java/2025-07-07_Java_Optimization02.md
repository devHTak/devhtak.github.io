### 4장 가비지 컬렉션 이해하기
#### 마크 앤 스윕 소개
- 마크 앤 스윕 알고리즘은 할당된 객체 리스트를 사용하여, 회수되지 않은 객체들의 포인터를 유지하는 방식으로 동작
  - 할당된 리스트를 순회하며 마크 비트(mark bit)를 초기화합니다.
  - 힙으로의 모든 포인터를 시작점으로하여 접근 가능한 모든 객체를 찾습니다.
  - 도달한 각 객체에 마크 비트를 설정
  - 할당된 리스트를 순회하며 마크 비트가 설정되지 않은 객체에 대한 작업 진행
    - 힙에서 해당 객체의 메모리를 회수하여 자유 리스트에 다시 추가
    - 객체를 할당된 리스트에서 제거
- 활성 객체는 DFS로 탐색되며 이렇게 만들어진 객체의 그래프를 활성 객체 그래프라 한다.
  - 접근 가능한 객체의 추이적 폐쇄라 부르며 반대로 접근할 수 없는 객체는 죽은 객체라고 부른다.

#### 가비지 컬랙션 용어집
- STW (Stop The World)
  - 가비지 컬렉션 사이클이 진행되는 동안 모든 애플리케이션 스레드를 멈춰야 한다.
- 동시성
  - 가비지 컬렉션 스레드가 애플리케이션 스레드가 실행되는 동안에도 동작할 수 있다.
  - G1은 일부 동시성 측면을 가지고 있다.
- 병렬
  - 가비지 컬렉션 작업을 여러 스레드와 여러 코어를 사용해 실행한다.
- 이동
  - 이동형 컬렉터에서는 객체가 메모리 내에서 재배치될 수 있다.
- 압축
  - 압축 컬렉터는 메모리 단편화를 방지
- 대피
  - 가비지 컬렉션 사이클이 끝날 때, 수집된 영역은 완전히 비워지고, 모든 활성 객체가 다른 메모리 영역으로 이동 된다.

#### 핫스팟 런타임 소개
- 자바는 오직 오프셋 연산자를 사용하여 객체 참조에서 필드에 접근하거나 메서드를 호출할 수 있다.
- 자바의 메소드 호출은 항상 값 복사 방식으로 이뤄지며 객체 참조의 경우, 힙에 있는 객체의 주소가 복사된다.
- 런타임에서 객체 표현
  - 핫스팟은 런타임에 자바 객체를 oop(ordinary object pointer)라는 구조를 통해 표현 (C에서 포인터를 의미)
    - 해당 값을 통해 스택 프레임에서 자바 힙의 메모리 영역으로 연결
  - oop는 인스턴스를 표현하는 instanceOop, 배열을 표현하는 경우에는 arrayOop라고 부른다.
    - klass워드는 klass 메타데이터를 찾는 데 사용
- 가비지 컬렉션 루트
  - 가비지 컬렉션 루트는 메모리의 앵커 포인트(anchor point)로 특정 메모리 풀 외부에서 시작하여 해당 메모리 풀 내부를 가리키는 외부 포인터를 의미
  - 반면, 메모리 풀 내부에서 시작하여 같은 메모리 풀 내의 다른 위치를 가리키는 포인터는 내부 포인터로 간주
- 마크 단계
  - GC는 루트객체에서 시작하여, 참조를 따라가며 도달 가능한 객체를 모두 탐색
  - 도달 가능한 객체킄 "마크"되어 살아있는 객체임을 기록
  - 마크되지 않은 객체는 더 이상 프로그램에서 접근할 수 없는 객체
- 스윕 단계
  - 힙 전체를 선형적으로 순회화며, 마크되지 않은 객체를 찾아 메모리에서 해제(삭제)
  - 마크된 객체는 그대로 두고, 마크만 초기화(다음 GC를 위해)

#### 할당과 수명 주기
- 자바 애플리케이션의 가비지 컬렉션 동작을 결정하는 두가지 주요 요인
  - 할당 속도
  - 객체의 수명 주기
- 할당 속도는 일정 시간동안 새로 생성된 객체가 사용하는 메모리의 양을 나타낸다.
  - JFR 같은 도구가 이를 제공할 수 있고 이를 사용하는 데 있어 성능에 영향을 미칠 가능성이 있다.
- 객체의 수명 주기는 측정/추정하기 어렵다.
  - 객체의 수명이 짧으면 동일한 물리적 메모리를 반복적으로 재사용할 수 있다.

#### 약한 세대 가설
- 자바 가상 머신과 유사한 소프트웨어 시스템에서 객체의 수명 분포는 이중 분포를 나타낸다.
- 대부분의 객체는 수명이 매우 짧은 반면, 일부 객체는 훨씬 더 긴 수명을 가지는 데, 힙이 두개의 별도 영역으로 나누어 가져야 한다.
  - eden, survive 0/1, old 영역으로 나뉜다.
- 세대를 나눈 이유는 객체의 생존 기간에 따라 효율적으로 메모리를 관리하고, GC 성능을 최적화하기 위함
  - 빠른 Minor GC로 불필요한 객체를 신속하게 제거하며 Major GC늬 빈도수를 낮추는 등 장수 객체의 효율적 관리가 가능하다.
  - 메모리 단편화를 줄이고 객체 생존 기간에 따른 최적화가 가능하다.
- 세대 별 역할
  - eden: 새로 생성된 객체가 위치하며 대부분의 객체가 여기에서 생성하고 곧바로 소멸
  - survive 0/1: eden에서 살아남은 객체가 임시로 이동하는 공간으로 두 공간을 이동하며 생존 횟수(age) 추적
  - old: 장수 객체가 저장되며 상대적으로 크고 GC 발생 빈도는 낮다.
- 세대별 힙을 사용하는 주요 이점 중 하나는 죽은 객체를 수집하는 데 비용이 들지 않고, 관심 대상은 오직 활성 객체 뿐이다.

#### 핫스팟의 프로덕션 가비지 컬렉션 기술
- 스레드 로컬 할당
  - 에덴은 힙의 영역 중 대부분의 객체가 생성되는 영역으로 다음 GC 사이클이 실행되기 전까지 생존하지 못하는 객체는 이 영역을 벗어나지 않는다.
  - 핫스팟은 에덴을 여러 개의 버퍼로 분할하고 각 애플리케이션 스레드에 독립적인 에덴 영역을 할당하여 새 객체를 생성하도록 한다.
  - 각 스레드가 자신에게 할당된 버퍼에서만 작업하므로 다른 스레드가 동일 버퍼에서 할당 작업을 수행하는 것을 걱정할 필요 없다.
  - 스레드-로컬 할당 버퍼라 하며 애플리케이션 스레드가 현재 스레드-로컬 할당 버퍼를 모두 채우면 자바 가상 머신은 엔덴의 새로운 영역 할당
- 반구형 컬렉션
  - 대피형 컬렉터의 사례로 이 유형의 컬렉터는 보통 같은 크기의 두 공간을 사용 (survivor 0/1)
  - 한 공간을 실제로 오래 지속되지 않는 객체의 임시 보관장소로 활용, 이를 통해 짧은 수명의 객체가 영구 세대로 혼입되는 것을 방지하고 전체 가비지 컬렉션의 빈도를 줄 일 수 있다.
  - 기본 속성
    - 컬렉터가 현재 활성화된 반구를 수집할 때, 객체는 압축 방식으로 다른 반구로 이동되며 수집된 반구는 재사용을 위해 비워진다.
    - 공간의 절반은 항상 완전히 비워진 상태로 유지
- 클래식 핫스팟 힙
  - 핫스팟 힙의 기본적인 특징
    - 각 객체의 '세대 카운트'를 추적
    - 큰 객체를 제외하고, 새 객체는 에덴 공간에 생성되며, 생존한 객체는 두 개의 서바이버 공간 중 하나로 이동
    - 메모리의 별도 영역(오래되었거나 영구한 세대)를 유지하며 일정 기간 생존한 객체를 저장, 이러한 객체는 오래 지속될 가능성이 높다고 간주

#### 병렬 컬렉터
- 사용 가능한 병렬 컬렉터
  - 병렬 가비지 컬렉션
    - 젊은 세대를 위한 가장 간단한 컬렉터
  - ParNew
    - 병렬 가비지 컬렉션의 변형된 버전, 더 아시아 사용되지 않는 동시 마크 스윕 컬렉터와 함꼐 사용
  - ParallelOld
    - 영구 세대를 위한 병렬 컬렉터
- 젊은 병렬 컬렉션
  - 스레드-로컬 할당 버퍼에 충분한 공간이 없고, JVM이 해당 스레드에 새로운 스레드-로컬 할당 버퍼를 할당할 수 없는 경우 발생
  - 가비지 컬렉션 루트를 시작으로하여 병렬 마킹 스캔 수행
    - 핫스팟은 젊은 세대(에덴과 현재 비어있지 않은 서바이버 공간)를 확인하고 가비지가 아닌 모든 객체 식별
  - 생존한 모든 객체는 현재 비어있는 서바이버 공간으로 이동하고 객체의 세대 카운트를 증가
- 오래된 병렬 컬렉션
  - ParallelOld는 자바 8까지 오래된 세대를 위한 기본 컬렉터로 단일 연속 메모리 공간을 사용하는 압축형 컬렉터다.
  - 오래된 세대엔 대피할 공간이 없기 때문에 오래된 객체가 소멸하며 남겨진 공간을 회수하기 위해 오래된 세대 내에서 객체 재배치
  - 이를 통해 컬렉터는 메모리를 매우 효율적으로 사용할 수 있으며, 메모리 단편화 문제를 피할 수 있다.
- 직렬 또는 SerialOld
  - 단일 코어만 STW 가비지 컬렉션을 수행하는 동안 나머지 CPU는 모든 유휴 상태로 남기 때문에, 불필요하게 긴 일시 중지 시간을 초래한다.
  - 따라서 특별한 이유가 없는 한 이런 컬렉터는 사용하지 않는 것이 좋다.

#### 할당의 역할
- 가비지 컬렉션은 메모리 할당 요청 시 메모리를 제공할만큼 충분한 여유가 없을 때 발생
- Major GC가 발생하면 애플리케이션 스레드가 중지되는 데, 이는 객체를 더 이상 생성할 수 없기 때문이며, 새로운 객체 없이 오랜 시간 실행할 수 없기 때문
- JVM은 모든 코어를 사용해 가비지 컬렉션을 수행하여 메모리를 회수한 뒤 애플리케이션 스레드를 다시 시작
- 가비지 컬렉터는 일정한 간격으로 실행되지 않고 필요에 따라 작동
  - 조기 승격: 할당 속도가 높아질수록 가비지 컬렉션은 더 자주 발생하며, 할당 속도가 지나치게 높을 경우 객체가 조기에 승격되는 상황
  - 가비지 컬렉션의 가장 중요한 간접적 영향으로 튜닝의 시작점이 된다.

### 5장 고급 가비지 컬렉션

### 6장 자바 가상 머신에서 코드 실행
