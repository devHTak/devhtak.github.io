### 4장 가비지 컬렉션 이해하기
#### 마크 앤 스윕 소개
- 마크 앤 스윕 알고리즘은 할당된 객체 리스트를 사용하여, 회수되지 않은 객체들의 포인터를 유지하는 방식으로 동작
  - 할당된 리스트를 순회하며 마크 비트(mark bit)를 초기화합니다.
  - 힙으로의 모든 포인터를 시작점으로하여 접근 가능한 모든 객체를 찾습니다.
  - 도달한 각 객체에 마크 비트를 설정
  - 할당된 리스트를 순회하며 마크 비트가 설정되지 않은 객체에 대한 작업 진행
    - 힙에서 해당 객체의 메모리를 회수하여 자유 리스트에 다시 추가
    - 객체를 할당된 리스트에서 제거
- 활성 객체는 DFS로 탐색되며 이렇게 만들어진 객체의 그래프를 활성 객체 그래프라 한다.
  - 접근 가능한 객체의 추이적 폐쇄라 부르며 반대로 접근할 수 없는 객체는 죽은 객체라고 부른다.

#### 가비지 컬랙션 용어집
- STW (Stop The World)
  - 가비지 컬렉션 사이클이 진행되는 동안 모든 애플리케이션 스레드를 멈춰야 한다.
- 동시성
  - 가비지 컬렉션 스레드가 애플리케이션 스레드가 실행되는 동안에도 동작할 수 있다.
  - G1은 일부 동시성 측면을 가지고 있다.
- 병렬
  - 가비지 컬렉션 작업을 여러 스레드와 여러 코어를 사용해 실행한다.
- 이동
  - 이동형 컬렉터에서는 객체가 메모리 내에서 재배치될 수 있다.
- 압축
  - 압축 컬렉터는 메모리 단편화를 방지
- 대피
  - 가비지 컬렉션 사이클이 끝날 때, 수집된 영역은 완전히 비워지고, 모든 활성 객체가 다른 메모리 영역으로 이동 된다.

#### 핫스팟 런타임 소개
- 자바는 오직 오프셋 연산자를 사용하여 객체 참조에서 필드에 접근하거나 메서드를 호출할 수 있다.
- 자바의 메소드 호출은 항상 값 복사 방식으로 이뤄지며 객체 참조의 경우, 힙에 있는 객체의 주소가 복사된다.
- 런타임에서 객체 표현
  - 핫스팟은 런타임에 자바 객체를 oop(ordinary object pointer)라는 구조를 통해 표현 (C에서 포인터를 의미)
    - 해당 값을 통해 스택 프레임에서 자바 힙의 메모리 영역으로 연결
  - oop는 인스턴스를 표현하는 instanceOop, 배열을 표현하는 경우에는 arrayOop라고 부른다.
    - klass워드는 klass 메타데이터를 찾는 데 사용
- 가비지 컬렉션 루트
  - 가비지 컬렉션 루트는 메모리의 앵커 포인트(anchor point)로 특정 메모리 풀 외부에서 시작하여 해당 메모리 풀 내부를 가리키는 외부 포인터를 의미
  - 반면, 메모리 풀 내부에서 시작하여 같은 메모리 풀 내의 다른 위치를 가리키는 포인터는 내부 포인터로 간주
- 마크 단계
  - GC는 루트객체에서 시작하여, 참조를 따라가며 도달 가능한 객체를 모두 탐색
  - 도달 가능한 객체킄 "마크"되어 살아있는 객체임을 기록
  - 마크되지 않은 객체는 더 이상 프로그램에서 접근할 수 없는 객체
- 스윕 단계
  - 힙 전체를 선형적으로 순회화며, 마크되지 않은 객체를 찾아 메모리에서 해제(삭제)
  - 마크된 객체는 그대로 두고, 마크만 초기화(다음 GC를 위해)

#### 할당과 수명 주기
- 자바 애플리케이션의 가비지 컬렉션 동작을 결정하는 두가지 주요 요인
  - 할당 속도
  - 객체의 수명 주기
- 할당 속도는 일정 시간동안 새로 생성된 객체가 사용하는 메모리의 양을 나타낸다.
  - JFR 같은 도구가 이를 제공할 수 있고 이를 사용하는 데 있어 성능에 영향을 미칠 가능성이 있다.
- 객체의 수명 주기는 측정/추정하기 어렵다.
  - 객체의 수명이 짧으면 동일한 물리적 메모리를 반복적으로 재사용할 수 있다.

#### 약한 세대 가설
- 자바 가상 머신과 유사한 소프트웨어 시스템에서 객체의 수명 분포는 이중 분포를 나타낸다.
- 대부분의 객체는 수명이 매우 짧은 반면, 일부 객체는 훨씬 더 긴 수명을 가지는 데, 힙이 두개의 별도 영역으로 나누어 가져야 한다.
  - eden, survive 0/1, old 영역으로 나뉜다.
- 세대를 나눈 이유는 객체의 생존 기간에 따라 효율적으로 메모리를 관리하고, GC 성능을 최적화하기 위함
  - 빠른 Minor GC로 불필요한 객체를 신속하게 제거하며 Major GC늬 빈도수를 낮추는 등 장수 객체의 효율적 관리가 가능하다.
  - 메모리 단편화를 줄이고 객체 생존 기간에 따른 최적화가 가능하다.
- 세대 별 역할
  - eden: 새로 생성된 객체가 위치하며 대부분의 객체가 여기에서 생성하고 곧바로 소멸
  - survive 0/1: eden에서 살아남은 객체가 임시로 이동하는 공간으로 두 공간을 이동하며 생존 횟수(age) 추적
  - old: 장수 객체가 저장되며 상대적으로 크고 GC 발생 빈도는 낮다.
- 세대별 힙을 사용하는 주요 이점 중 하나는 죽은 객체를 수집하는 데 비용이 들지 않고, 관심 대상은 오직 활성 객체 뿐이다.

#### 핫스팟의 프로덕션 가비지 컬렉션 기술
- 스레드 로컬 할당
  - 에덴은 힙의 영역 중 대부분의 객체가 생성되는 영역으로 다음 GC 사이클이 실행되기 전까지 생존하지 못하는 객체는 이 영역을 벗어나지 않는다.
  - 핫스팟은 에덴을 여러 개의 버퍼로 분할하고 각 애플리케이션 스레드에 독립적인 에덴 영역을 할당하여 새 객체를 생성하도록 한다.
  - 각 스레드가 자신에게 할당된 버퍼에서만 작업하므로 다른 스레드가 동일 버퍼에서 할당 작업을 수행하는 것을 걱정할 필요 없다.
  - 스레드-로컬 할당 버퍼라 하며 애플리케이션 스레드가 현재 스레드-로컬 할당 버퍼를 모두 채우면 자바 가상 머신은 엔덴의 새로운 영역 할당
- 반구형 컬렉션
  - 대피형 컬렉터의 사례로 이 유형의 컬렉터는 보통 같은 크기의 두 공간을 사용 (survivor 0/1)
  - 한 공간을 실제로 오래 지속되지 않는 객체의 임시 보관장소로 활용, 이를 통해 짧은 수명의 객체가 영구 세대로 혼입되는 것을 방지하고 전체 가비지 컬렉션의 빈도를 줄 일 수 있다.
  - 기본 속성
    - 컬렉터가 현재 활성화된 반구를 수집할 때, 객체는 압축 방식으로 다른 반구로 이동되며 수집된 반구는 재사용을 위해 비워진다.
    - 공간의 절반은 항상 완전히 비워진 상태로 유지
- 클래식 핫스팟 힙
  - 핫스팟 힙의 기본적인 특징
    - 각 객체의 '세대 카운트'를 추적
    - 큰 객체를 제외하고, 새 객체는 에덴 공간에 생성되며, 생존한 객체는 두 개의 서바이버 공간 중 하나로 이동
    - 메모리의 별도 영역(오래되었거나 영구한 세대)를 유지하며 일정 기간 생존한 객체를 저장, 이러한 객체는 오래 지속될 가능성이 높다고 간주

#### 병렬 컬렉터
- 사용 가능한 병렬 컬렉터
  - 병렬 가비지 컬렉션
    - 젊은 세대를 위한 가장 간단한 컬렉터
  - ParNew
    - 병렬 가비지 컬렉션의 변형된 버전, 더 아시아 사용되지 않는 동시 마크 스윕 컬렉터와 함꼐 사용
  - ParallelOld
    - 영구 세대를 위한 병렬 컬렉터
- 젊은 병렬 컬렉션
  - 스레드-로컬 할당 버퍼에 충분한 공간이 없고, JVM이 해당 스레드에 새로운 스레드-로컬 할당 버퍼를 할당할 수 없는 경우 발생
  - 가비지 컬렉션 루트를 시작으로하여 병렬 마킹 스캔 수행
    - 핫스팟은 젊은 세대(에덴과 현재 비어있지 않은 서바이버 공간)를 확인하고 가비지가 아닌 모든 객체 식별
  - 생존한 모든 객체는 현재 비어있는 서바이버 공간으로 이동하고 객체의 세대 카운트를 증가
- 오래된 병렬 컬렉션
  - ParallelOld는 자바 8까지 오래된 세대를 위한 기본 컬렉터로 단일 연속 메모리 공간을 사용하는 압축형 컬렉터다.
  - 오래된 세대엔 대피할 공간이 없기 때문에 오래된 객체가 소멸하며 남겨진 공간을 회수하기 위해 오래된 세대 내에서 객체 재배치
  - 이를 통해 컬렉터는 메모리를 매우 효율적으로 사용할 수 있으며, 메모리 단편화 문제를 피할 수 있다.
- 직렬 또는 SerialOld
  - 단일 코어만 STW 가비지 컬렉션을 수행하는 동안 나머지 CPU는 모든 유휴 상태로 남기 때문에, 불필요하게 긴 일시 중지 시간을 초래한다.
  - 따라서 특별한 이유가 없는 한 이런 컬렉터는 사용하지 않는 것이 좋다.

#### 할당의 역할
- 가비지 컬렉션은 메모리 할당 요청 시 메모리를 제공할만큼 충분한 여유가 없을 때 발생
- Major GC가 발생하면 애플리케이션 스레드가 중지되는 데, 이는 객체를 더 이상 생성할 수 없기 때문이며, 새로운 객체 없이 오랜 시간 실행할 수 없기 때문
- JVM은 모든 코어를 사용해 가비지 컬렉션을 수행하여 메모리를 회수한 뒤 애플리케이션 스레드를 다시 시작
- 가비지 컬렉터는 일정한 간격으로 실행되지 않고 필요에 따라 작동
  - 조기 승격: 할당 속도가 높아질수록 가비지 컬렉션은 더 자주 발생하며, 할당 속도가 지나치게 높을 경우 객체가 조기에 승격되는 상황
  - 가비지 컬렉션의 가장 중요한 간접적 영향으로 튜닝의 시작점이 된다.

### 5장 고급 가비지 컬렉션
#### 트레이드오프와 플러그형 컬렉터
- 오라클, OpenJDK 환경에서 가비지 컬렉터 서브시스템은 플러그인이 가능한 형태로 사용
  - 즉, 자바 프로그램에서도 다른 가비지 컬렉터로 바꾸어 실행할 수 있으며 이에 따라 성능이 크게 달라진다.
- GC를 선택할 때에 주요 고려 사항
  - 애플리케이션 STW
  - 처리량(애플리케이션 실행 시간 대비 GC 실행 시간의 비율로 측정)
  - 일시 중지 빈도(컬렉터가 애플리케이션을 중지해야 하는 빈도)
  - 회수 효율성 (단일 가비지 컬렉터가 수집할 수 있는 가비지의 양)
  - 일시 중지의 일관성 (모든 일시 중지가 대부분 일정한 길이인지 여부)
- CPU 효율성
  - 대규모 병렬처리 애플리케이션에선 지연시간보다 처리량을 더 중요하게 고려해야 한다.
  - 배치 작업 등 애플리케이션의 처리량이 많고 작업이 정해진 시간 내에 완료될 수 있다면 수십 초의 일시 중지도 큰 영향을 미치지 않는다.
- 압축
  - ParallelOld 컬렉터는 압축을 특정으로 하며, 다른 많은 컬렉터도 압축 기능을 포함하고 있다.
  - 압축은 관련 객체들을 인접한 메모리 위치에 배치하는 방식으로 동작하며, 캐시 라인에서 이미 적재 상태일 가능성이 더 높다.
  - 따라서 객체들이 가까이 있을수록 메모리 접근이 더 효율적 

#### 동시 가비지 컬렉션 이론
- GC의 비결정성(non-determinism) 은 직접적인 메모리 할당 동작으로 발생하며, 자바가 사용되는 많은 시스템은 매우 가변적인 메모리 할당 특성을 보인다.
- 더 큰 문제는 범용적으로 설계된 GC가 특정 사용 도메인에 대한 정보를 갖고 있지 않아 일시 정지의 결정성을 개선할 수 있는 방법이 없다.
- GC는 애플리케이션 세부사항을 알지 못하고 단지 힙에 있는 실제 사용중인 객체의 그래프만 추적하여 비결정성을 더욱 심화시킨다.
- 자바 가상 머신 세이프 포인트
  - 세이프 포인트란 JVM이 가비지 컬렉션(GC), 힙 덤프, 클래스 재정의 등과 같은 특정 관리 작업을 안전하게 수행하기 위해 모든 애플리케이션 스레드의 실행을 일시적으로 중단시킬 수 있는 특별한 실행 지점 의미
  - (작동방식) JVM은 실제로 완전히 선점형 멀티스레딩 환경이 아니며 운영 체제는 얼마든지 스레드를 선점할 수 있다.
    - JVM은 임의로 스레드를 세이프 포인트 상태로 강제 전환할 수 없다.
    - 대신 스레드가 세이프 포인트에 도달하면 그 상태에서 벗어나지 못하게 할 수 있습니다.
    - 세이프 포인트 요청이 발생하면, 각 스레드는 코드 실행 도중 주기적으로 세이프 포인트 플래그를 확인(폴링)
    - 요청이 감지되면 해당 지점에서 멈춰서 관리 작업이 끝날 때까지 대기합니다.
  - (삽입 위치) JIT 컴파일러는 루프 백 브랜치, 메서드 반환, 객체 할당 등 자바 코드 내 여러 지점에 세이프 포인트 체크 코드를 삽입합니다. 이로 인해 모든 스레드가 비교적 빠르게 세이프 포인트에 도달할 수 있습니다

- 삼색 마킹(Tri-color Marking)
  - 삼색 마킹 알고리즘은 가비지 컬렉션(GC)에서 객체의 생존 여부를 판별하기 위해 사용하는 Tracing 알고리즘.
  - 이 방식은 흰색, 회색, 검은색 세 가지 색으로 객체의 상태를 구분
    - 흰색: 아직 마킹되지 않은 객체로, GC 루트에서 도달할 수 있는지 미확인 상태입니다. 최종적으로 해당 객체는 수집 대상
    - 회색: GC 루트에서 도달 가능. 그 객체가 참조하는 다른 객체들은 아직 마킹하지 않은 상태입니다. (처리 진행 중)
    - 검은색: GC 루트에서 도달 가능. 해당 객체가 참조하는 모든 객체까지 마킹이 끝난 상태입니다. (라이브 객체로 GC 대상 제외)    - Concurrent GC와 같이 애플리케이션 스레드와 GC 스레드가 동시에 동작하는 환경에서 객체 그래프를 안전하게 탐색
  - 삼색 마킹의 동작 원리
    - 초기 상태: 모든 객체를 흰색으로 표시하고, GC 루트 집합(스택, 정적 변수 등)에서 시작합니다.
    - 마킹 과정
      - GC 루트에서 참조하는 객체를 회색으로 바꿉니다.
      - 회색 객체를 하나씩 꺼내어, 그 객체가 참조하는 흰색 객체를 다시 회색으로 바꿉니다.
      - 이미 처리한 회색 객체는 검은색으로 바꿉니다.
      - 이 과정을 회색 객체가 모두 없어질 때까지 반복합니다.
    - 마킹 종료
      - 모든 객체가 흰색(수집 대상) 또는 검은색(살아있는 객체)으로 구분됩니다. 남아 있는 흰색 객체는 더 이상 참조되지 않으므로 메모리에서 해제됩니다.
  - 삼색 마킹의 특징과 장점
    - 동시성 지원
      - 애플리케이션 스레드와 GC 스레드가 동시에 객체 그래프를 변경해도, 마킹의 정확성을 유지할 수 있습니다. 이를 위해 SATB(Snapshot At The Beginning)와 같은 보조 기법을 활용하기도 합니다.
    - Stop-The-World 시간 최소화
      - 일부 단계(초기 마킹, 재마킹)만 STW로 처리하고, 대부분의 마킹 작업을 애플리케이션과 병행하여 수행할 수 있습니다
- 포워딩 포인터

#### G1

#### ZGC

### 6장 자바 가상 머신에서 코드 실행
#### 전통적인 자바 애플리케이션

#### 바이트코드 해석 개요

#### 핫스팟에서의 JIT 컴파일

#### 자바 프로그램 실행의 진화
