### 레디스 운용 관리

#### 데이터 영속성
- 레디스는 인메모리 DB 특성 상 기본적으로 모든 데이터를 메모리에서 처리하기 떄문에 서버가 재시작되면 데이터가 유실 될 수 있다.
- 캐시로 사용한다면 성능상의 이슈는 발생할 수 있지만 데이터 휘발성이 큰 문제가 되지 않는다.
  - 그러나 캐시 미스로 인해 RDBMS에 다시 데이터를 요청할 때 성능에 어느 정도 영향을 미치는지, 과부하가 발생하지 않는지 등을 충분히 검토해야 한다.
- 캐시가 아닌 데이터 저장소처럼 데이터 영속성을 전제로 운영하는 경우
  - 영속성을 위한 설정이 있지만, 영속성 관련 기능을 모두 활성화하는 것은 권장하지 않는다.
  - 성능과 내구성의 타협점을 찾고 그에 맞춰 설정해야 한다.
- 레디스는 snapshot과 AOF 두가지 방법으로 데이터 영속성 보장
  - snapshot, AOF, snapshot + AOF, 영속성을 사용하지 않는 4가지 방법이 있고, 이 방식을 사용해 백업을 만들 수 있다.
- 기본적으로 snapshot 이 기본값으로 설정되어 있음

##### 스냅샷
- 특정 시점의 DB 내에 있는 내용을 RDB(Redis Database)라는 형식의 파일로 저장
- 수동에 경우 SAVE(동기), BGSAVE(비동기) 명령어 사용
  - SAVE 명령어는 동일한 스레드내에 RDB 파일을 생성하기 때문에 Dump 중에 다른 요청은 차단되므로 실제 운영에선 사용하지 않는다.
  - BGSAVE는 RDB 덤프하기 위한 자식 프로세스를 포크처리하여 생성한 후 자식 프로세스가 데이터 세트 전체를 임시 RDB 파일로 덤프한다.
  - 이후 덤프처리가 완료되면 RDB 파일 이름 변경
- 자동으로 설정하면 정해진 시간 내에 최소 몇개의 키가 변경되었는지 기준 설정
- RDB 파일을 덤프하기 위한 자식 프로세스를 생성할 때는 CoW(Copy On Write) 메커니즘을 사용해 메모리를 확보
- RDB 파일은 Amazon S3 등에 저장하여 운영할 수 있으며, 복원을 위해 지정한 디렉터리에 배치하여 실행
  - 그 외 파일 압축, 체크섬 등 튜닝할 수 있다.
- 백그라운드에서 snapshot 처리에 실패하게 되면, 기본적으로 쓰기 작업 요청을 수락하지 않는다.

##### AOF(Append Only File)
- snapshot의 단점은 레디스에 장애가 발생하면 이전 snapshot 이후 데이터는 당연히 손실된다.
- 반면 AOF는 거의 실시간 백업 처럼 작성중인 파일 끝에 계속 추가하여 기록하기 때문에 내구성이 높다.
- AOF는 자동 생성만 할 수 있다.

##### snapshot과 AOF 비교
- snapshot 장점
  - 특정 시점의 상태를 덤프하며 파일 크기가 작다
  - 자식 프로세스의 포크 처리 시에만 성능 영향을 미치며 나머지 처리는 백그라운드에서 수행되어 성능에 미치는 영향이 작다
- snapshot 단점
  - 데이터 손실 가능
- AOF 장점
  - 데이터 내구성이 높다
- AOF 단점
  - 트랜잭션 로그를 REDO 로그 형태로 기록하며, 실제 데이터를 기록하지 않기 떄문에 같은 데이터 세트라도 AOF 파일 크기가 더 커질 수 있다.
  - snapshot 보다 성능 저하에 미치는 영향이 더 크며 레디스 서버를 시작할 때 파일 로딩에 시간이 걸릴 수 있다.

##### 데이터 삭제 패턴
- 데이터 손실될 수 있는 상황
  - 엔진 재시작
  - 레디스 서버 전체 장애
  - 명령어 실행(DEL, FLUSHALL, UNLINK ..)
  - TTL 만료 (EXPIRE, SET 명령어의 EX 옵션)
  - 강제 제거
  - 비동기 레플리케이션
  - 레디스 클러스터의 네트워크 단절
  - 기타 (키 이름 재설정 등)
- 레디스 레플리카는 비동기 형태를 취하기 때문에 반영되지 않은 상태에서 마스터가 다운되면 데이터 손실이 발생할 수 있다.
- 네트워크 단절 영향이 있을 수 있다.
- AWS Elasticache 관리형에 경우 데이터 삭제 복원에 대해 이해 필요
  - 장애 감지 및 자동 복구
    - ElastiCache는 기본 노드(Primary)나 읽기 전용 복제본(replica)에서 장애가 발생하면 이를 자동으로 감지하고, 해당 노드를 오프라인 상태로 전환한 뒤 새 노드를 생성하고 동기화
    - 읽기 전용 복제본이 장애 시, 동일한 가용 영역(AZ)에서 대체 노드를 자동으로 생성. 이 기간에도 애플리케이션은 다른 복제본과 기본 노드 사용 가능
  - 자동 장애 조치(Automatic Failover)
    - 다중 AZ 구성에서는 기본 노드에 장애가 발생하면 가장 최신 데이터를 가진 읽기 전용 복제본이 자동으로 Primary로 승격
    - 기존 엔드포인트를 계속 사용할 수 있어 애플리케이션 변경 불필요
    - 장애 감지~복구까지 일반적으로 6분 이내 완료. 장애 조치 중에는 아웃풋 메시지로 상태 변경을 알리므로 모니터링 가능
  - 재해 복구/데이터 손실 가능성
    - Redis 복제는 비동기식이므로, 장애 시점에 따라 소량의 데이터가 손실 가능
    - ElastiCache는 복제 지연이 가장 짧은 최신 복제본을 Primary로 선택해 데이터 손실을 최소화
    - 전체 클러스터 장애(모든 노드에 장애 발생)와 같은 극히 드문 경우에는 데이터가 완전히 손실될 수 있으며, 이 경우 백업 또는 스냅샷으로 복구해야 한다.
  - 백업 및 복원
    - 관리 콘솔 또는 API를 통해 자동 또는 수동 백업(스냅샷)을 설정할 수 있으며 장애나 데이터 손실 시, 이전 시점의 데이터로 클러스터를 복원 가능
  - 운영 자동화
    - 노드의 상태 감지, 장애 복구, 패치, 백업, 가용성 유지 등은 AWS가 자동화하여 관리합니다.
  - 장애 조치 시 주의 사항
    - 고객이 직접 실행하는 노드 재부팅은 자동 장애조치를 트리거하지 않습니다.

#### 모범사례
##### TTL 설정
- 레디스를 캐시 서버로 사용하는 경우, 기본적으로 데이터가 소실되어도 큰 문제가 없는 데이터 저장
- 데이터 키에는 캐시에 보관할 최소 시간을 TTL로 설정하고, 시간이 지나면 만료되도록 설정하며 TTL을 통해 데이터가 노후화되는 것을 방지할 수 있다.

##### 제거 정책 설정
- 메모리 사용량이 maxmemory 지시자로 설정된 값에 도달하면, 레디스는 메모리 확보를 위해 키를 제거한다.
  - 제거 방식은 maxmemory-policy 지시자로 설정된 정책에 따라 결정
  - TTL이 설정된 키를 대상으로 volatile- 로 시작하는 정책 선택
  - 데이터 저장소로 사용하는 경우, 모든 키를 대상으로 allkeys- 로 시작하는 정책 선택
- LRU, LFU, 랜덤, TTL 기반으로 한 정책 선택은 데이터 특성을 고려하여 설정해야 한다.

##### 백업
- 백업 방법으로 AOF, snapshot 중 snapshot을 사용하는 경우 메모리 확보, 생성 시점, 레플리카로부터 생성하기 등 설정을 할 수 있다.
- 포크를 통해 생성된 새로운 스레드로 RDB 파일이 생성되는 방식으로 메모리 할당은 CoW 방식 사용
  - CoW(Copy on Write) 란, 메모리 할당 및 사용을 최적화하기 위한 기법
  - 데이터의 복사가 요청될 때 실제로는 복사를 즉시 수행하지 않고, 원본 데이터와 복사본이 메모리를 공유하도록 하다가 실제 내용이 변경(쓰기)될 때 그 시점에 복사를 수행하는 방식
- 새로운 스레드는 부모 스레드와 같은 범위의 메모리 영역을 사용하며 마스터와 레플리카에 변경이 발생하면 개별적으로 메모리 영역을 준비해 분리하여 사용
  - 관리형 서비스에 경우 데이터 이외 용도로 사용하는 메모리 영역을 예약할 수 있으며 25% 정도의 메모리만 확보해도 충분
  - ElastiCache는 reserved-max-memory-percent 지시자를 제공하며 메모리가 부족할 때 포크없이 스냅샷을 생성할 수 있다.

##### 커넥션 풀링
- 매번 새롭게 연결을 만들면 그에 따른 비용과 오버헤드가 발생하기 때문에 클라이언트에서 커넥션 풀링 기능을 제공한다.
  - 연결 재사용으로 처리 효율성을 높일 수 있다
- 최대 동시 연결수는 maxclients 지시자로 설정 가능하며 기본값은 10,000 이다.
  - 관리형에 경우 65,000으로 고정되어 변경할 수 없는 경우도 있다.
- 레디스가 열 수 있는 파일 디스크립터의 최대 개수는 커널에 의해 소프트 제한이 걸려 ㅣㅇㅆ다.
  - 클라이언트의 최대 개수에 32를 더한 값이 상한선으로 결정된다
  - 32는 데이터의 영속성, 소켓의 리스닝, 로그 파일등의 내부 작업을 위해 필요한 개수

##### 재시도 처리
- 클라이언트와 서버간 통신이 일시적으로 중단되었을 때 클라이언트 측에서 재시도 처리를 수행하는 것이 효과적일 수 있다.
  - 재시도 횟수, 타임아웃 값, 재시도 간격, 횟수 등의 설정을 중요한 요소로 고려해야 한다.
- 재시도 방법은 지수 백오프 알고리즘에 기반한 방법이 좋다.
  - 지수 백오프 알고리즘이란 대기 시간(wait time)*을 점진적으로(지수적으로) 증가시키는 재시도 전략으로
  - 대기 시간 = 기본 대기 시간 × 2^ 재시도 횟수 공식 사용

##### 기타 모범 사례
- 클라이언트 측에 설정된 소켓 타임아웃 시간
  - 값이 너무 작으면 레디스 서버에 부하가 증가할 때마다 타임아웃 오류가 자주 발생할 수 있고, 너무 크면 연결 문제를 감지하는 데 오래 걸릴 수 있다.
- 레디스 서버에 연결하기 위해 FQDN(Fully Qualified Domain Name)을 사용하고 잇고 DNS 캐시를 사용하는 경우 TTL을 작게 설정하는 것이 좋다.

#### 캐시 노드 크기 조정

##### 크기 조정 기준
- 레디스 클러스터
  - 클러스터를 구축하는 경우 최소 3개의 캐시 노드를 마스터로 설정해야 한다.
  - 클러스터를 구성하고자 판단할 때에는 주로 부하가 높은 쓰기 작업을 처리하는 경우거나 높은 가용성이 요구되는 경우인지 판단 필요
- 클러스터 내부 동작 방식 이해 필요
  - 여러 노드로 구성된 분산 시스템으로, 데이터를 해시 슬롯 단위로 분산 저장하고, 마스터-슬레이브 구조를 통해 고가용성과 자동 장애 조치(Failover)를 제공
  - 해시 슬롯 기반 샤딩
    - 모든 키는 CRC16 해시 연산을 통해 0~16383 사이의 16,384(2^14)개 해시 슬롯 중 하나에 매핑
    - 각 마스터 노드는 특정 슬롯 범위를 담당하며, 키가 어느 슬롯에 속하는지에 따라 저장 위치가 결정
    - 슬롯 분배 정보는 모든 노드에 공유되어 데이터 요청이 효과적으로 분산됩니다.
  - 마스터-슬레이브 구조
    - 마스터 노드마다 최소 하나 이상의 슬레이브 노드를 두며 마스터 장애 시 슬레이브가 자동으로 승격되어 서비스 연속성을 확보
    - 마스터는 읽기/쓰기 요청 처리, 슬레이브는 실시간 복제를 통해 장애 상황 발생 시 복구를 지원합니다.
  - 노드 간 통신 방식
    - Gossip Protocol
      - 모든 노드는 주기적으로 다른 노드와 상태 정보를 교환(ping/pong)하여 장애를 감지합니다.
      - 과반수 이상의 노드가 장애 상태에 동의하면 해당 노드가 Fail로 선언됩니다.
    - Full-mesh & Cluster Bus
      - 노드들은 전용 채널(일반 Redis 포트 + 10000, 예: 6379→16379)을 통해 내부 메시지와 상태 정보를 교환합니다.
  - 클러스터 특징 및 제한
    - 데이터베이스 분할 불가(DB0만 사용): 클러스터 모드에서는 하나의 DB(0번)만 사용 가능하며, 내부적으로 분할되어 저장
    - Multi-key 연산 제한: 키들이 같은 슬롯에 있을 때만 정상적으로 동작
    - 확장성 & Rebalance: 노드를 추가·삭제 시 슬롯 재분배를 통해 자동으로 데이터와 부하를 분산 가능
  - 고가용성 및 장애 처리:
    - 장애 발생 시 슬레이브 승격(Auto Failover)을 통해 즉시 복구가 이루어집니다.
    - 네트워크 파티션 등 다양한 장애 상황도 Gossip 프로토콜과 과반수 판정 방식으로 관리
- 실제 용도에 맞는 요구사항 추정
  - 전체 데이터 양, 최대치일 때 키의 개수, 키 당 평균 크기 및 최대 크기, 초당 키의 작업 수, 트래픽, 명령어 내역 등 고려
- 클라우드 크기 조정
  - 클라우드 서비스를 사용하는 경우, 백업 기능 지원 여부, 노드 크기별 특성, 레디스 버정 별 엔진 기능 등도 고려
 
#### 보안
- ACL(Access Control List - 접근 제어 목록) 기능을 사용하거나 사용자 입력을 검증한느 중간계층을 추가하는 방식 권장

##### 보안 설정
- 네트워크 보안
  - bind 지시자를 통해 IP 주소 지정 가능
  - TLS 기능 사용
    - redis-cli는 --tls 옵션을 사용할 수 있느며 클라이언트가 지원하지 않는 경우 Spiped, stunnel 같은 프록시 사용 가능
  - 기본적으로 보호모드가 활성화 되어 있다
    - 루프백 인터페이스와 유닉스 도메인 소켓에서만 접근 가능
- 명령어 제한
  - 외부로부터 명령어 실행을 방지하기 위해 특정 명령어를 비활성화할 수 있다.
  - rename-command 지시자를 사용하여 CONFIG/FLUSHALL/FLUSHDB 같은 명령어 제한을 둘 수 있다
- 인증
  - requirepass 명령어를 통해 설정 파일에 패스워드 설정 인증 기능 제공
  - AUTH 명령어를 통해 패스워드를 지정하고 연결할 수 있다

##### ACL 기능
- 유스 케이스
  - 신뢰할 수 없는 클라이언트에 접근을 허용하지 않고, 신뢰할 수 있는 클라이언트에게만 최소한의 접근 권한 부여
    - 특정 명령어나 키만 지정하여 접근 허용 가능
  - 사용자의 실수 예방
    - 버그로 인한 의도하지 않은 키 조작 방지
  - 관리형 서비스
- ACL 기능을 통한 제어 내용
  - ACL LIST 명령어로 레디스 서버 내에 사용가능한 사용자 및 접근 제어 상세 내용 확인 가능
  - ACL CAT <<CATEGORY_NAME>> 형태로 카테고리에 포함된 명령어 확인 가능
- ACL 기능 설정 방법
  - 제어 방법
    - ACL SETUSER 명령어
    - 설정 파일에 user 지시자 지정
    - 설정 파일에 aclfile 지시자를 통해 acl.conf 와 같은 외부 파일 지정

#### 벤치 마크



