### 메모리 관리

#### 1. 메모리 관리 아키텍처
- 레디스 메모리 구조
  - 데이터
  - 데이터 구조 오버헤드
  - 클라이언트 쿼리 버퍼
  - 클라이언트 출력 버퍼
  - AOF 버퍼
  - AOF 재작성 버퍼
  - 레플리케이션 백로그
  - 레디스 함수
  - 이페머럴 스크립트
  - 메모리 단편화
 
##### INFO Memory 출력 결과 해석
- used_memory: 레디스가 jemalloc 같은 메모리 할당자를 사용해 할당한 메모리 크기 
  - 해당 메모리는 클라이언트 출력 버퍼 등도 포함되어 데이터만 사용하는 것이 아니다
- maxmemory: 레디스가 사용할 수 있는 최대 메모리 크기
- used_memory가 maxmemory 를 넘으면 maxmemory-policy 지시자로 설정한 값을 따르도록 동작
  - mem_not_counted_for_evict 는 AOF 버퍼, RDB 스냅샷을 생성할 때 CoW 에 의해 사용된 메모리양의 합으로
  - used_memory - mem_not_counted_for_evict <= maxmemory
- used_memory_overhead 는 서버에 할당된 오버헤드를 관리하는 데 사용되는 내부 데이터 구조
  - used_memory_dataset = used_memory - used_memory_overhead (데이터 세트의 메모리 크기)
- mem_cluster_links 값과 send-buffer-allocated 값
  - 레디스 클러스터의 클러스터 버스에서 캐시 노드가 다른 노드와의 연결에 사용하는 메모리 정보
- mem_fragmentation_ratio: 메모리 단편화 비율
  - 레디스가 현재 사용중인 것으로 인식하는 메모리 사용량을 RSS 값을 나눈 값
  - mem_fragmentation_ratio = used_memory_rss / used_memory
- 메모리 단편화 문제 대처 방법
  - 단편화율이 1.5 이상이면 단편화가 심각하고 성능 문제가 발생할 수 있다.
  - 반대로 1.0 보다 낮으면 스왑이 발생하고 있을 가능성이 있다.
  - 단편화 발생 시 대처 방법
    - 레디스 재시작 (RDB, AOF 파일 불러오기를 통해 데이터 복원)
    - 동적 단편화
    - 메모리 스왑 제한
    - 메모리 할당자 변경
    - MEMORY PURGE 명령어 실행
      - 메모리 사용량이 높은 최대 사용량 시간에도 jemalloc 메모리를 즉시 해제하지 않는 상황에서 메모리를 재사용하고자 할 떄 유용

##### 클라이언트 출력 버퍼(COB Client Output Buffer)
- COB는 서버로부터 데이터를 즉시 읽지 못하는 클라이언트의 연결을 강제로 끊는 용도로 사용
- 서버는 클라이언트마다 COB를 갖추고 처리한 결과를 클라이언트에 보내지 않고 COB 저장, COB에 저장된 정보가 클라이언트에 한번에 전송
  - 버퍼 크기가 커질 수 있는 상황은 다루는 "데이터 크기가 클 때", "스토리지가 느릴 때", "네트워크 환경이 좋지 않을 때"
- 클라이언트 출력 버퍼 종류
  - pubsub 유형(redis pub/sub 기능)은 버퍼 크기에 제한을 두어 클라이언트의 출력 버퍼가 초과되면 연결을 끊을 수 있다
  - replica 유형은 마스터에서 버퍼링하는 영역
  - normal 유형은 일반적인 클라이언트의 연결에 사용되는 버퍼 영역
  - client-output-buffer-limit 지시자는 레디스에서 클라이언트 출력 버퍼의 크기 제한을 설정할 때 사용

#### 2. 키 만료
- 최대한 캐시 내의 데이터를 재사용하고 DB 접근 횟수를 줄여 효율적으로 운용할 필요가 있다.
- 현재 데이터와 크게 다르지 않다면 TTL을 설정해서 적절하게 관리할 필요가 있다.

##### 만료 방법
- TTL이 만료되면 대상 키가 메모리에서 삭제되는 것이 아닌 메모리에 남게 되는 데 이 데이터를 삭제하는 방법 의미
- 수동적 방법
  - 접근할 때 해당 키의 TTL을 확인하여 만약 만료되었다면 해당 키를 메모리에서 삭제
- 능동적 방법
  - 레디스가 매 초마다 10번, 임의로 20개의 키를 샘플링하여 만료된 키를 확인하고 삭제
  - 샘플링된 키 중 25% 이상이 만료된 경우 삭제 과정 반복
- 레디스 서버에는 백그라운드로 일정 시간마다 실행되는 타이머 이벤트가 있다.
- 만료 주기 방식
  - 레디스는 이벤트 루프 기반 작동하지만, 빠른 만료 주기는 이 이벤트 루프의 각 주기마다 실행되며 만료된 키의 비율이 10% 이하이거나 메모리 전체 25% 이하의 크기를 소비하도록 동작

##### 삭제 정책
- 메모리 사용량이 maxmemory 지시자로 설정된 값에 도달했을 때, 메모리 확보를 위해 키를 삭제하는 과정이 이뤄진다.
- 리눅스에서는 메모리 사용량이 캐시 노드의 메모리를 압박할 경우 OOM Killer가 활성화되어 프로세스를 강제 종료할 수 있다.
  - 레디스 서버가 중된될 수 있으므로 모니터링해야 한다.
- LFU 메커니즘
  - 사용 빈도가 가장 낮은 항목을 삭제대상으로 선택하는 알고리즘
  - 밑수를 정하고, 지수 부분만 기억해서 계산을 통해 실제 사용 빈도를 추정하는 방식
  - 지수가 커질수록 더 자주 사용된다고 간주하므로 데이터를 사용할 때마다 지수가 올라간다.
  - 확률을 기반으로 근사치를 계산하는 방식이기 때문에 지수값이 클수록 오차가 커지게 된다.
  - 각 키에 접근할 때마다 카운터 증가, 시간이 지나면 카운터 감소, 카운터 값이 낮은 키 삭제 동작
- LRU 메커니즘
  - 메모리 할당 시 가장 오랫동안 사용되지 않은 키를 삭제 대상으로 선정하는 방법
  - 레디스의 LRU 방식은 무작위로 선택된 일정 수의 아이템 중 가장 오랫동안 사용되지 않은 아이템을 대상으로 정한다.

#### 3. 메모리를 효율적으로 사용하기 위한 기타 방법
- 메모리를 효율적으로 사용하기 위한 동적 리해싱(active rehashing), 동적 단편화 제거(active defragmentation) 기법

##### 동적 리해싱
- 레디스는 하나의 큰 해시 테이블을 사용해 데이터 관리
  - 동적 리해싱 방식은 해당 해시 테이블 크기를 사용하려는 상황에 맞추어 자동 조정
  - CPU 시간의 100ms 중 1ms 만큼 사용하여 리해싱 중인 테이블 관련 작업이 있을 때마다 점진적 진행
- 해시 테이블의 크기는 2의 거듭 제곱 단위로 충돌 시 체이닝 방식 사용
- 리해싱 과정에서 크기가 조정된 새로운 테이블 추가, 새로운 아이템이 이 테이블에 저장되도록 한다.
  - 데이터가 모두 이동하면 이전 테이블 삭제
  - 만약 레디스의 응답으로 인해 쿼리가 2ms 만큼 지연되는 것이 문제된다면 비활성화하는 것이 좋다.
- activerehashing 지시어로 활성화할 수 있다.

##### 동적 단편화 제거
- 메모리 단편화가 발생할 수 있다.
  - 단편화는 모든 메모리 할당자에서 발생하지만 jemalloc 은 그중에서도 단편화가 덜 발생하도록 설계되어 있어 사용하는 것 권장
- 동적 단편화 제거 기법을 사용하면 재시작 같은 조치없이도 단편화 문제를 해결할 수 있다.
  - 특정 임계값을 초과하면 jemalloc 기능을 사용하여 연속된 메모리 영역에 새로운 데이터의 레플리카 생성 후 오래된 데이터를 해제하는 방식 진행
  - 모든 키에 대해 점진적으로 반복적으로 수행하여 정상 범위까지 감소

### 클라우드에서 사용하는 레디스
- AWS ElastiCach는 레디스와 멤키시를 사용하는 예시로 설명

#### 1. OSS와 레디스 차이
- OSS 버전의 레디스를 운영할 경우 사용자가 직접 장애 대응이나 메트릭 모니터링 등을 관리해야 하지만, ElastiCache는 관리형 서비스이기 때문에 사용자 수고를 덜 수 있다.
- ElastiCache 제공
  - 완전 관리
    - 하드웨어 프로비저닝, 소프트웨어 패치 적용, 셋업설정 작업, 모니터링, 장애 시 자동 복구
  - 쉬운 스케일링, 백업/복원 기능, 이벤트 알림 기능, 셀프서비스 업데이트 기능
  - 자동 페일 오버, 스왑 메모리 관리, 온라인 리샤딩, 자동 쓰기 슬롯 스로틀링, 안전성 및 규정 준수
  - 지역 간 레플리케이션 기능, 데이터 계층화, 자동 스케일링

##### 고유 기능
- 이벤트 알림 기능
- 셀프서비스 업데이트 기능
- 자동 페일오버
- 멀티AZ
- 온라인 리샤딩
- 안전성과 보안 관리
- I/O 처리 멀티스레드화
- 리전 간 레플리케이션 기능
- 온라인으로 계획적인 유지보수 실행하기
- 데이터 계층화
- 자동 스케일링

##### 제한
- 일부 기능이나 명령어 사용 제한
  - ex) 관리 콘솔에서는 AOF를 사용할 수 없고 스냅샷 생성 방식 사용 가능
- 모든 요구사항에 대응하기 어려울 수 있어 충족 여부 확인 필요

#### 2. 클라우드에서 사용하는 방법
- 가능한 한 ElasiCache의 사용 가능한 최신 버전을 사용하는 것이 좋다.
- 왭 브라우저 내에서 관리 콘솔 화면을 따라 다음과 같은 항목을 입력해 생성할 수 있다.
  - 레디스 클러스터 이름
  - 버전 지정
  - 레디스 클러스터 사용 여부(ElastiCache 에서는 클러스터 모드 활성/비활성이란 용어 사용)
- 엔드포인트
  - redis-cli를 사용하여 원격 호스트에서 운영 중인 레디스 서버 접근 (-h)
    - -c 옵션을 사용하여 클러스터 기능을 활성화할 수 있다.
  - 노드별로 엔드포인트가 발급되며 이를 통해 노드 연결 가능
  - 매개변수는 ElastiCache에서 관리하기 때문에 일부는 편집할 수 없거나 OSS 버전과 다른 기본값을 가지고 있는 경우, 캐시 노드 타입별로 값이 정해져 있는 경우 존재
    - 동적, 정적 타입이 있으며 동적 타입은 변경 후 즉시 반영되지만 정적 타입은 설정을 반영하려면 재시작 필요

#### 3. 클라우드를 활용한 트러블슈팅
