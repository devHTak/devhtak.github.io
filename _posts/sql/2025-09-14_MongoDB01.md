### 01. MongoDB

#### MongoDB vs MySQL
- 객체의 이름이 조금 다를 뿐 RDBMS와 비슷한 역할을 한다.
  - 데이터베이스, 컬렉션, 도큐먼트, 필드, 인덱스
- 쿼리 결과를 'Cursor' 로 반환하는 데, 커서를 통해 반복적으로 실제 도큐먼트(레코드)를 가져올 수 있다.
- MongoDB 특징
  - NoSQL
    - 기본적으로 SQL을 사용하지 않지만 MongoDB Connector for BI, Simba의 SQL Driver 등을 사용하면 비슷하게 통신 할 수 있다.
    - 외래키를 명시적으로 지원하지 않지만 $lookup 이라는 Aggregation 기능을 이용하면 조인 처리를 수행(샤딩 제약)할 수 있다.
    - SQL, NoSQL 간의 경계가 허물어지고 있다.
  - Schema-Free
    - 가장 큰 차이점으로 사용할 컬럼을 미리 정의하지 않고 언제든 필요한 시점에 데이터를 저장할 수 있다.
  - 비 관계형 데이터베이스
    - SQL 문법을 지원하지 않고 자바스크립트 기반의 명령을 이용하는 데, JSON 도큐먼트를 인자로 사용

#### MongoDB Architecture

<img width="426" height="309" alt="image" src="https://github.com/user-attachments/assets/bb86f9fc-1890-4abc-b356-7c57086329af" />
- 출처: Real MongoDB
- MongoDB 서버의 구성 요소에서 가장 아래에 위치한 스토리지 엔진은 사용자 데이터를 디스크에 저장하거나 디스크로부터 읽어 쿼리 프로세서 모듈 전달

#### MongoDB 배포 형태
- MongoDB 도 HBase, Casandra 같이 클러스터 형태로 서비스할 수 있도록 구현된 DB 서버다.
  - 하지만 꼭 클러스터 형태로 구성해야만 사용할 수 있는 것은 아니다.
- 배포형태는 MySQL 서버의 구조와 매우 비슷하다.
  - 단일 서버로도 사용 가능하며 복제 또는 샤딩된 구조로도 활용 가능하다.
- 단일 노드
  - 해당 배포 형태는 MongoDB는 복제를 위한 로그(OpLog)를 별도로 기록하지 않으며 다른 노드와 통신도 필요하지 않다.
  - 자동 페일오버나 HA 기능이 작동할 수 없어 주로 개발 서버의 구성에 사용
- 단일 레플리카 셋
  - 레플리카 셋 구축을 위해 추가로 MongoDB 서버 필요
  - 장애 상황에서 자동 복구를 위한 최소 단위로 바동 복구가 필요하다면 레플리카 셋으로 MongoDB 배포 필요
  - 노드 간 투표를 통해 Primary 노드를 결정하므로 가능하면 홀수 개의 노드로 구성하는 것이 좋다
  - Arbiter 모드
    - replica set 구성에서 장애 조치와 리더 선출을 위해 투표만 하는 역할을 수행하는 노드 모드입니다.
    - Arbiter의 역할과 특징
      - Arbiter는 데이터 복제를 하지 않고, 오로지 투표 목적으로만 존재합니다.
      - Primary와 Secondary 노드에서 선거(election)가 발생할 때 Arbiter가 투표에 참여해 quorum(과반수)를 채워 줍니다.
      - Arbiter는 직접적인 데이터 저장이나 읽기, 쓰기 연산을 하지 않아 서버 리소스를 거의 소모하지 않습니다.
      - 장애 whcl(failover) 시, Primary 장애 발생 시 Secondary 승격 여부를 결정합니다.
- 샤딩된 클러스터
  - 샤딩된 클러스터에 참여하고 있는 각각의 레플리카 셋을 샤드라고 하는 데, 이 샤드들이 어떤 데이터를 가지는지에 대한 정보는 MongoDB Config 서버 필요
  - 샤딩된 클러스터에서 MongoDB 드라이버는 MongoDB 라우터(mongos)로 연결하고, 자동으로 컨피그 서버로부터 각 샤드가 가지고 있는 데이터에 대한 메타 정보들을 참조하여 쿼리 실행
  - 요청된 쿼리를 실제 데이터를 가지고 있는 샤드로 전달하는 역할 수행, 이후 결과를 정렬 및 병합해 반환
### 02. Storage Engine
