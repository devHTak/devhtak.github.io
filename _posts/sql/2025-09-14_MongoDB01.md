### 01. MongoDB

#### MongoDB vs MySQL
- 객체의 이름이 조금 다를 뿐 RDBMS와 비슷한 역할을 한다.
  - 데이터베이스, 컬렉션, 도큐먼트, 필드, 인덱스
- 쿼리 결과를 'Cursor' 로 반환하는 데, 커서를 통해 반복적으로 실제 도큐먼트(레코드)를 가져올 수 있다.
- MongoDB 특징
  - NoSQL
    - 기본적으로 SQL을 사용하지 않지만 MongoDB Connector for BI, Simba의 SQL Driver 등을 사용하면 비슷하게 통신 할 수 있다.
    - 외래키를 명시적으로 지원하지 않지만 $lookup 이라는 Aggregation 기능을 이용하면 조인 처리를 수행(샤딩 제약)할 수 있다.
    - SQL, NoSQL 간의 경계가 허물어지고 있다.
  - Schema-Free
    - 가장 큰 차이점으로 사용할 컬럼을 미리 정의하지 않고 언제든 필요한 시점에 데이터를 저장할 수 있다.
  - 비 관계형 데이터베이스
    - SQL 문법을 지원하지 않고 자바스크립트 기반의 명령을 이용하는 데, JSON 도큐먼트를 인자로 사용

#### MongoDB Architecture

<img width="426" height="309" alt="image" src="https://github.com/user-attachments/assets/bb86f9fc-1890-4abc-b356-7c57086329af" />
- 출처: Real MongoDB
- MongoDB 서버의 구성 요소에서 가장 아래에 위치한 스토리지 엔진은 사용자 데이터를 디스크에 저장하거나 디스크로부터 읽어 쿼리 프로세서 모듈 전달

#### MongoDB 배포 형태
- MongoDB 도 HBase, Casandra 같이 클러스터 형태로 서비스할 수 있도록 구현된 DB 서버다.
  - 하지만 꼭 클러스터 형태로 구성해야만 사용할 수 있는 것은 아니다.
- 배포형태는 MySQL 서버의 구조와 매우 비슷하다.
  - 단일 서버로도 사용 가능하며 복제 또는 샤딩된 구조로도 활용 가능하다.
- 단일 노드
  - 해당 배포 형태는 MongoDB는 복제를 위한 로그(OpLog)를 별도로 기록하지 않으며 다른 노드와 통신도 필요하지 않다.
  - 자동 페일오버나 HA 기능이 작동할 수 없어 주로 개발 서버의 구성에 사용
- 단일 레플리카 셋
  - 레플리카 셋 구축을 위해 추가로 MongoDB 서버 필요
  - 장애 상황에서 자동 복구를 위한 최소 단위로 바동 복구가 필요하다면 레플리카 셋으로 MongoDB 배포 필요
  - 노드 간 투표를 통해 Primary 노드를 결정하므로 가능하면 홀수 개의 노드로 구성하는 것이 좋다
  - Arbiter 모드
    - replica set 구성에서 장애 조치와 리더 선출을 위해 투표만 하는 역할을 수행하는 노드 모드입니다.
    - Arbiter의 역할과 특징
      - Arbiter는 데이터 복제를 하지 않고, 오로지 투표 목적으로만 존재합니다.
      - Primary와 Secondary 노드에서 선거(election)가 발생할 때 Arbiter가 투표에 참여해 quorum(과반수)를 채워 줍니다.
      - Arbiter는 직접적인 데이터 저장이나 읽기, 쓰기 연산을 하지 않아 서버 리소스를 거의 소모하지 않습니다.
      - 장애 whcl(failover) 시, Primary 장애 발생 시 Secondary 승격 여부를 결정합니다.
- 샤딩된 클러스터
  - 샤딩된 클러스터에 참여하고 있는 각각의 레플리카 셋을 샤드라고 하는 데, 이 샤드들이 어떤 데이터를 가지는지에 대한 정보는 MongoDB Config 서버 필요
  - 샤딩된 클러스터에서 MongoDB 드라이버는 MongoDB 라우터(mongos)로 연결하고, 자동으로 컨피그 서버로부터 각 샤드가 가지고 있는 데이터에 대한 메타 정보들을 참조하여 쿼리 실행
  - 요청된 쿼리를 실제 데이터를 가지고 있는 샤드로 전달하는 역할 수행, 이후 결과를 정렬 및 병합해 반환

### 02. Storage Engine

#### 플러그인 스토리지 엔진
- 스토리지 엔진들은 사용자의 데이터를 디스크에 영구적으로 기록하거나 다시 읽어와서 메모리에 적재하는 역할 담당
  - MongoDB는 MMAPv1, WiredTiger 스토리지 엔진을 선택하여 사용할 수 있고 동시에 사용할 수 없다.
- 옵티마이저라고 부르는 컴포넌트가 처리를 담당하는 데, 최적화된 실행 계획을 수립해준다.

#### MMAPv1 스토리지 엔진
- MMAPv1 특징
  - MongoDB 3.0 까지 주로 사용되던 스토리지 엔진으로 2.6까지는 데이터베이스 단위의 잠금 사용
    - DML 문장의 동시 처리 성능이 좋지 않았는데, 컬렉션 수준 잠금으로 개선되면서 동시성 처리로 변경, 하지만 동시성 처리에 많은 걸림돌이 된다.
  - 내장된 캐시 기능이 없어 운영체제의 캐시 활용
    - 윈도우 캐시를 사용하기 때문에 System call 을 거치게 되어 오버헤드가 상대적으로 크다
- 데이터 파일 구조
  - 데이터 파일은 데이터베이스 단위로 생성된다.
    - storage.smallFiles 옵션을 이용하면 크기를 작게 만들 수 있다. (default 64MB)
  - stage.directoryPerDB 옵션은 디스크의 데이터 파일을 데이터베이스 단위로 별도의 디렉터리에 저장할 것인지 결정
    - true / false
  - database.ns 파일
    - 몽고DB 서버에 생성된 데이터베이스와 컬렉션 그리고 인덱스 정보 저장
  - systemLog.path, processManagement.pidFilePath 옵션을 이용해 생성될 디렉터리

- MongoDB 서버 상태 확인
  - mongostat 도구를 통해 현재 서버의 쿼리 처리량, 메모리 사용량과 같은 전체적인 상태를 볼 수 있다

- 운영체제 캐시
  - 내장된 캐시가 없고 OS에서 제공하는 패이지 캐시 기능에 의존
    - 내장된 캐시가 없기 때문에 더티 페이지를 효율적으로 관리하는 기능이 없다.
    - 많이 발생하는 문제는 Cache Invalidation 현생 (페이지 캐시 삭제)
  - 리눅스 페이지 캐시에 의존하기 때문에 커널의 작동 방식, 파라미터 튜닝이 필수적이며 그 중 디스크의 페이지를 읽어들이는 방식과 페이지 캐시가 갖고 있는 더티 페이지가 디스크를 동기화 하는 방식에 대한 이해가 필수적이다.
  
- 데이터 파일 프레그멘테이션
  - Fragmentation: 도큐먼트의 크기가 계속 증가하면 기존의 작은 공간들은 재활용하지 못하고 계속 빈 공간이 남게 되는 데, 이런 현상이 반복되면 사용하지 못하는 공간이 늘어나게 된다.
  - Fragementation 가 많으면 같은 블록 하나를 읽어도 가져올 수 있는 도큐먼트 개수가 달라지므로 메모리 효율성, 성능 차이가 발생
  - db.collection.stats() 명령어를 통해 확인 가능
    - count: 도큐먼트 건수
    - size: 컬렉션의 전체 도큐먼트 크기
    - storageSize: 컬렉션을 위해 할당된 전체 디스크 데이터 파일 크기
    - avgObjSize: 도큐먼트 하나의 평균 크기
    - paddingFactor: MMAPv1 스토리지 엔진을 사용하여 컬렉션에서만 패딩 사용
  - 디스크 데이터 파일 크기를 줄이기 위해서 컴팩션하거나 세컨드리 멤버의 데이터를 덤프한 후에 다시 적재
    - compaction을 수행하는 경우에 paddingBytes, paddingFactor 옵션 추가 가능

#### WiredTiger 스토리지 엔진
- 특징
  - 내부적인 잠금 경합 최소화(Lock-free algorithm)을 위해 "하자드 포인터", "스킵 리스트" 와 같은 기술 채택
  - MVCC와 데이터 파일 압축, 암호화 기능들을 모두 가지고 있다
- 저장 방식
  - 3가지 타입의 저장소
    - 레코드 스토어: 컬렉션의 레코드를 한번에 저장하는 방식으로 B-Tree 알고리즘 사용
    - 컬럼 스토어: 대용량의 분석 용도로 많이 사용되며 컬럼 단위 또는 컬럼 그룹 단위로 데이터 파일 관리, 데이터 파일 크기가 작아 읽어들이는 속도가 매우 빠르다
    - LSM(Log Structured Merge Tree) 스토어
      - 읽기보단 쓰기에 집중된 저장방식으로 순차 파일 형태로 데이터를 저장하며 시간 순서대로 1개 이상이 관리된다.
      - 메모리에 디스크로 갓 저장된 파일을 Level-0 파일이 되고 조각이 많아지면 이들을 모아 Level-1 데이터 파일 조각을 만든다.
      - 이렇게 n까지 계속 성장하는 방식으로 작동하며 레벨이 높을수록 오래된 데이터로 구성
      - 읽을 떄는 N개의 데이터 파일을 읽어야 하기 때문에 읽기 성능은 떨어지나 대용량의 insert를 문제없이 처리하기 위해 사용
- 데이터 파일 구조
- 내부 작동 방식
- 공유 캐시
- 캐시 이빅션(Cache Eviction)
- 체크 포인트
- MVCC (Multi Version Concurrency Control)
- 데이터 블록 (페이지)
- 운영체제 캐시 (페이지 캐시)
- 압축
- 암호화
