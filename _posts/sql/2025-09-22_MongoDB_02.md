### 05. 인덱스

#### 디스크 읽기 방식
- 랜덤 I/O(Random I/O)
  - 데이터를 비연속적인(물리적으로 떨어진) 위치에서 임의로 읽거나 쓰는 작업이다.
  - 디스크 헤드가 여러 위치로 이동해야 하므로, 작업당 seek time(탐색 시간)·latency가 크게 증가한다.
  - 인덱스 기반 탐색, WHERE 조건 조회, 특정 레코드 단건 접근, 임의 위치 갱신·삭제 등에서 주로 발생한다.
  - HDD에서는 랜덤 I/O가 매우 느리며, SSD는 그 차이가 적지만 throughput(처리량)은 여전히 낮은 편이다.
    - ex) 인덱스 레인지 스캔, 키 값 하나씩 랜덤 조회 등.
- 순차 I/O(Sequential I/O)
  - 물리적으로 연속된(붙은) 위치에서 데이터를 순서대로 읽거나 쓴다.
  - 디스크 헤드를 거의 이동시키지 않고, 한 번 seek한 뒤 연달아 데이터를 읽거나 쓸 수 있다.
  - 전체 테이블 스캔, 대량 정렬·그룹화, 연속 블록 덤프 등에서 발생.
  - 대용량 데이터 일괄 처리에 유리하며, HDD·SSD 모두에서 랜덤 I/O보다 월등히 빠르다.
  - ex) 풀 테이블 스캔(모든 로우 직접 읽기), 파일 연속 저장 등.
- 성능 개선 관점
  - DB 쿼리 성능을 높이려면 랜덤 I/O를 최소화하고, 순차 I/O가 많이 발생하도록 데이터 구조·쿼리를 최적화하는 것이 바람직하다.
  - 이는 꼭 필요한 데이터만 읽고 쓰도록 설계하거나, 액세스 패턴을 연속적으로 유지하는 방식으로 이뤄질 수 있다.

#### 인덱스란?
- 모든 데이터를 뒤져서 원하는 결과를 가져오는 데에 시간이 걸리기 때문에 컬럼과 레코드가 저장된 위치를 key-value 관리
  - DBMS의 인덱스도 컬럼의 값을 주어진 순서로 미리 정렬해서 가지고 있다.
  - SortedList: DBMS의 인덱스와 동일한 자료 구조로 정렬된 상태 유지
    - 저장하는 과정은 복잡하고 느리지만 원하는 값을 빠르게 찾을 수 있다.
  - ArrayList: 데이터 파일과 동일한 자료 구조 사용로 저장된 순서 그대로 유지 
- 인덱스는 데이터 저장 방식에 따라 분류할 수 있으며 대표적으로 B-Tree 인덱스, Hash 인덱스가 있다
- 데이터 중복 여부에 따라 unique index, non-unique index로 구분할 수 있다

#### MongoDB 인덱스의 개요

#### B-Tree 인덱스

#### Hash 인덱스

#### 멀티 키 인덱스

#### 전문 검색 인덱스

#### 인덱스 속성
