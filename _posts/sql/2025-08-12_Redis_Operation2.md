### 레플리카

#### 레플리케이션 기능
- 실제 운영 환경에서는 장애나 네트워크 연결 문제, 시스템 충돌같은 문제를 예방하기 위해 다중노드로 구성
- 레디스는 다중 노드를 운영하기 위한 레플리케이션 기능 제공
  - master-replica 구조는 지속적으로 마스터의 업데이트를 여러 레플리카에 반영
  - 최근에는 master-slave 구조라는 표현이 아닌 master-replica 구조로 명칭한다

##### 비동기 처리를 통한 구현
- 레플리케이션은 이벤트 루프의 비동기 논블로킹 방식으로 구현
- 지연이 발생할 때 데이터가 동일하지 않을 수 있다.

##### 레플리케이션을 사용할 때 레디스 연결 방법
- ElastiCache 를 사용하는 경우, 클러스터에서는 다음과 같은 엔드포인트를 사용할 수 있으므로 프록시 등을 직접 준비하고 관리하는 수고를 줄일 수 있다.
  - 마스터에 대한 요청 라우팅은 프라이머리 엔드포인트이다
  - 레플리카에 대한 요청 라우팅은 리더 엔드포인트이다

##### 기본적으로 읽기 전용인 레플리카
- 레플리카를 추가하여 읽기 작업의 부하를 관리할 수 있다.
  - 레플리카에 쓰기 작업이 가능한 경우 데이터 일관성이 깨질 위험이 있다

##### 마이그레이션 활용
- 새로운 레디스 서버로 마이그레이션할 때 다운타임을 최소화하기 위해 레플리케이션 기능을 활용할 수 있다.

##### 레플리케이션 주의사항
- 레플리케이션 작업을 실행할 때 마스터에 영속성이 설정되어 있지 않은 경우, 엔진을 재시작하거나 종료하면 데이터 세트가 초기화된 상태로 실행
- 레플리카도 초기화되므로 주의해야 한다.

#### 레플리케이션을 시작할 때 메커니즘
- 레플리케이션 구성 과정
  - 레플리카는 PSYNC 명령어로 마스터에 연결을 요청하며 해당 시점까지 처리한 레플리케이션 ID와 오프셋 전송
  - 마스터는 요청받은 마스터의 레플리케이션 ID와 자신의 레플리케이션 ID가 일치하는지 확인하고 오프셋이 레플리케이션 백로그의 버퍼에 있는 지 확인
  - 요청 받은 오프셋이 레플리케이션 백로그에 있는지에 따라 처리가 달라진다.
    - 레플리케이션 백로그에서 동기화 가능한 경우: 요청된 오프셋이 레플리케이션 백로그에 있고, 백로그에서 동기화 가능한 경우에는 부분 동기화 실행
    - 레플리케이션 백로그에서 동기화가 불가능한 경우: 레플리케이션 중단 중에 마스터가 받은 쓰기 작업 요청의 크기가 버퍼 크기를 초과하여 부분 동기화가 불가능한 경우에는 전체 동기화 실행

##### 전체 동기화
- 전체 동기화 수행 메커니즘
  - 레플리카가 마스터에 레플리케이션 시작 요청
  - 마스터는 BGSAVE 명령어를 실행하여 프로세스를 포크 러치, 포크된 프로세스에서 메모리 스냅샷(RDB) 진행
  - BGSAVE 처리 완료 후 RDB 파일을 레플리카로 전송
    - 그동안 마스터으 쓰기 작업은 레플라키의 클라이언트 출력 버퍼에 기록, 레플리카는 전송된 RDB 파일을 메모리로 불러온다
  - RDB 파일 전송 완료 후 레플리카의 클라이언트 출력 버퍼에 기록된 데이터를 레플리카로 전송
  - 레플리카의 클라이언트 출력 버퍼에 쓰기 작업이 완료되면, 마스터의 쓰기 작업은 실시간 레플리카로 계속 전송
- 전체 동기화를 시작할 떄의 세부사항
  - TODO
- 여러 개의 레플리카가 있을 때의 동작
- 레플리케이션 연결이 끊길 때의 동작
- TTL 설정된 키의 레플리케이션 동작
- 디스크없는 레플리케이션
- 그 외 레플리케이션 최적화를 위한 확인 사항

##### 부분 동기화
- 레플리케이션 연결이 끊어진 동안의 모든 쓰기 작업이 레플리케이션 백로그에서 레플라카로 전송
- 마스터에는 레플리케이션 백로그라고 불리는 고정길이의 리스트 위에 있는 메모리 영역이 있다 (default 1MB)
- 동기식 레플리케이션 강제하기
  - WAIT 명령어 사용: 레플리케이션 강제 동기식 수행
    - 데이터 손실에 대한 안전성을 높일 수 있으며 페일오버 도중 쓰기 작업을 받ㄴ은 레플리카를 새로운 마스터로 효율적으로 승격시킬 수 있다.
  - 비동기 레플리카 특성 상 마스터에 장애 발생 시 데이터 손실될 수 있다.
    - RDB에서 데이터를 가져오는 등의 방법으로 처리할 필요가 있다
  - WAIT 명령어 등으로 동기 레플리케이션 구현하는 경우, 동기화 과정이 성능에 부담을 줄 수 있으므로 성능에 미치는 영향도 고려해야 한다

#### 레플리케이션 동작 중 메커니즘
- 마스터와 레플리카 간의 연결 상태 모니터링
  - 마스터는 기본적으로 10초 간격으로 레플리카에 ping을 보낸다.
  - 레플리카는 매초 REPLCONF ACK <offset> 명령어를 사용하여 ping을 보내고, 마스터는 레플리카의 마지막 ping 기록
- 핑 타임아웃이 지정되어 있어 설정한 시간이 지날 떄까지 ping이 오지 않으면 레플리케이션 연결이 끊긴다

#### 페일 오버
- 마스터에 문제가 발생했을 때 자동으로 failover 하는 기능이 기본적으로 없다.
  - 마스터가 다운되었을 때 새로운 마스터로 승격시킬 노드에서 REPLCAOF NO ONE 명령어를 수동으로 실행해야 한다.
  - 레디스 클러스터나 레디스 센티널을 사용하면 자동 failover 기능을 사용할 수 있다.
- 페일오버 중에는 CLIENT PAUSE 명령어로 클라이언트 접근을 일시적으로 중단하여 쓰기 작업이 새로운 마스터로 향하게 할 수도 있다.

#### 레디스 센티널
- 모니터링, 알림, 자동 페일오버 등 레디스에 고가용성 제공
- 레디스 센티널은 하나의 마스터와 하나 이상의 레플리카로 구성된 레디스 서버와 적어도 세개의 캐시노드에서 작동하는 신테널로 구성
  - 센티널은 파스터나 레플리카와 동일한 노드 또는 다른 캐시 노드에서 운영할 수 있다.
- 여러 센티널 캐시 노드가 특정 노드를 사용할 수 없다고 확인되면 장애로 감지
  - 장애 관련 판단은 단일 노드의 판단과 모든 노드의 합의라는 관점의 균형을 통해 자동 페일오버가 이뤄진다.
- SDOWN(Subjectively Down Condition), ODOWN(Objectively Down Condition)
