### 레플리카

#### 레플리케이션 기능
- 실제 운영 환경에서는 장애나 네트워크 연결 문제, 시스템 충돌같은 문제를 예방하기 위해 다중노드로 구성
- 레디스는 다중 노드를 운영하기 위한 레플리케이션 기능 제공
  - master-replica 구조는 지속적으로 마스터의 업데이트를 여러 레플리카에 반영
  - 최근에는 master-slave 구조라는 표현이 아닌 master-replica 구조로 명칭한다

##### 비동기 처리를 통한 구현
- 레플리케이션은 이벤트 루프의 비동기 논블로킹 방식으로 구현
- 지연이 발생할 때 데이터가 동일하지 않을 수 있다.

##### 레플리케이션을 사용할 때 레디스 연결 방법
- ElastiCache 를 사용하는 경우, 클러스터에서는 다음과 같은 엔드포인트를 사용할 수 있으므로 프록시 등을 직접 준비하고 관리하는 수고를 줄일 수 있다.
  - 마스터에 대한 요청 라우팅은 프라이머리 엔드포인트이다
  - 레플리카에 대한 요청 라우팅은 리더 엔드포인트이다

##### 기본적으로 읽기 전용인 레플리카
- 레플리카를 추가하여 읽기 작업의 부하를 관리할 수 있다.
  - 레플리카에 쓰기 작업이 가능한 경우 데이터 일관성이 깨질 위험이 있다

##### 마이그레이션 활용
- 새로운 레디스 서버로 마이그레이션할 때 다운타임을 최소화하기 위해 레플리케이션 기능을 활용할 수 있다.

##### 레플리케이션 주의사항
- 레플리케이션 작업을 실행할 때 마스터에 영속성이 설정되어 있지 않은 경우, 엔진을 재시작하거나 종료하면 데이터 세트가 초기화된 상태로 실행
- 레플리카도 초기화되므로 주의해야 한다.

#### 레플리케이션을 시작할 때 메커니즘
- 레플리케이션 구성 과정
  - 레플리카는 PSYNC 명령어로 마스터에 연결을 요청하며 해당 시점까지 처리한 레플리케이션 ID와 오프셋 전송
  - 마스터는 요청받은 마스터의 레플리케이션 ID와 자신의 레플리케이션 ID가 일치하는지 확인하고 오프셋이 레플리케이션 백로그의 버퍼에 있는 지 확인
  - 요청 받은 오프셋이 레플리케이션 백로그에 있는지에 따라 처리가 달라진다.
    - 레플리케이션 백로그에서 동기화 가능한 경우: 요청된 오프셋이 레플리케이션 백로그에 있고, 백로그에서 동기화 가능한 경우에는 부분 동기화 실행
    - 레플리케이션 백로그에서 동기화가 불가능한 경우: 레플리케이션 중단 중에 마스터가 받은 쓰기 작업 요청의 크기가 버퍼 크기를 초과하여 부분 동기화가 불가능한 경우에는 전체 동기화 실행

##### 전체 동기화
- 전체 동기화 수행 메커니즘
  - 레플리카가 마스터에 레플리케이션 시작 요청
  - 마스터는 BGSAVE 명령어를 실행하여 프로세스를 포크 러치, 포크된 프로세스에서 메모리 스냅샷(RDB) 진행
  - BGSAVE 처리 완료 후 RDB 파일을 레플리카로 전송
    - 그동안 마스터으 쓰기 작업은 레플라키의 클라이언트 출력 버퍼에 기록, 레플리카는 전송된 RDB 파일을 메모리로 불러온다
  - RDB 파일 전송 완료 후 레플리카의 클라이언트 출력 버퍼에 기록된 데이터를 레플리카로 전송
  - 레플리카의 클라이언트 출력 버퍼에 쓰기 작업이 완료되면, 마스터의 쓰기 작업은 실시간 레플리카로 계속 전송
- 전체 동기화를 시작할 떄의 세부사항
  - TODO
- 여러 개의 레플리카가 있을 때의 동작
- 레플리케이션 연결이 끊길 때의 동작
- TTL 설정된 키의 레플리케이션 동작
- 디스크없는 레플리케이션
- 그 외 레플리케이션 최적화를 위한 확인 사항

##### 부분 동기화
- 레플리케이션 연결이 끊어진 동안의 모든 쓰기 작업이 레플리케이션 백로그에서 레플라카로 전송
- 마스터에는 레플리케이션 백로그라고 불리는 고정길이의 리스트 위에 있는 메모리 영역이 있다 (default 1MB)
- 동기식 레플리케이션 강제하기
  - WAIT 명령어 사용: 레플리케이션 강제 동기식 수행
    - 데이터 손실에 대한 안전성을 높일 수 있으며 페일오버 도중 쓰기 작업을 받ㄴ은 레플리카를 새로운 마스터로 효율적으로 승격시킬 수 있다.
  - 비동기 레플리카 특성 상 마스터에 장애 발생 시 데이터 손실될 수 있다.
    - RDB에서 데이터를 가져오는 등의 방법으로 처리할 필요가 있다
  - WAIT 명령어 등으로 동기 레플리케이션 구현하는 경우, 동기화 과정이 성능에 부담을 줄 수 있으므로 성능에 미치는 영향도 고려해야 한다

#### 레플리케이션 동작 중 메커니즘
- 마스터와 레플리카 간의 연결 상태 모니터링
  - 마스터는 기본적으로 10초 간격으로 레플리카에 ping을 보낸다.
  - 레플리카는 매초 REPLCONF ACK <offset> 명령어를 사용하여 ping을 보내고, 마스터는 레플리카의 마지막 ping 기록
- 핑 타임아웃이 지정되어 있어 설정한 시간이 지날 떄까지 ping이 오지 않으면 레플리케이션 연결이 끊긴다

#### 페일 오버
- 마스터에 문제가 발생했을 때 자동으로 failover 하는 기능이 기본적으로 없다.
  - 마스터가 다운되었을 때 새로운 마스터로 승격시킬 노드에서 REPLCAOF NO ONE 명령어를 수동으로 실행해야 한다.
  - 레디스 클러스터나 레디스 센티널을 사용하면 자동 failover 기능을 사용할 수 있다.
- 페일오버 중에는 CLIENT PAUSE 명령어로 클라이언트 접근을 일시적으로 중단하여 쓰기 작업이 새로운 마스터로 향하게 할 수도 있다.

#### 레디스 센티널
- 모니터링, 알림, 자동 페일오버 등 레디스에 고가용성 제공
- 레디스 센티널은 하나의 마스터와 하나 이상의 레플리카로 구성된 레디스 서버와 적어도 세개의 캐시노드에서 작동하는 신테널로 구성
  - 센티널은 파스터나 레플리카와 동일한 노드 또는 다른 캐시 노드에서 운영할 수 있다.
- 여러 센티널 캐시 노드가 특정 노드를 사용할 수 없다고 확인되면 장애로 감지
  - 장애 관련 판단은 단일 노드의 판단과 모든 노드의 합의라는 관점의 균형을 통해 자동 페일오버가 이뤄진다.
- SDOWN(Subjectively Down Condition), ODOWN(Objectively Down Condition)

### 레디스 클러스터

#### 레디스 클러스터 기능 개요
##### 장점
- 레플리케이션에 경우 마스터의 레플리카 수를 늘려 읽기 작업의 확장성을 높일 수 있지만, 쓰기 작업에 경우 확장성을 높이기 어렵다
- 레디스 클러스터는 샤딩 제공
  - 각 샤드는 한개의 마스터와 0개 이상의 레플리카로 구성, 여러 샤드를 설정하여 샤드 수만큼 배치 가능
  - DB 내의 데이터를 슬롯에 할당한 후 샤드들이 담당한 슬롯을 결정해 어느 샤드에 데이터를 저장할 지 결정
- 클라이언트 요청에 대해 클러스터 내 각 노드로 요청을 분배하는 과정에서 프록시를 사용하지 않는다.
  - 갖고 있지 않은 노드에 요청이 오면, 클라이언트에게 데이터를 가진 마스터 노드 정보를 제공하고 리다이렉트 한다
- 16384개의 해시 슬롯이 있으며, 각 샤드에 할당된다. 데이터를 저장할 해시 슬롯을을 선택하기 위해 키 값의 해시 결과 사용

##### 두개의 TCP 포트
- 클라이언트로 요청을 받는 6379 포트 사용
- 클러스터 내부 통신을 위한 포트로 10,000을 더한 포트 사용(6379라면 16379)
  - 클러스터 버스 포트라 한다.
- 각 노드는 클러스터 버스를 통해 다른 모든 노드와 연결되며 통신에는 이진 프로토콜 사용
  - 완전 메시 구조로 구성되며 노드 간에 구성 정보, 상태와 같은 정보 교환
  - 페일 오버 인증, 설정 업데이트 등에 사용되는 하트비트 패킷 교환도 이뤄진다.
- Raft 라는 분산 합의 알고리즘을 기반으로 시스템 구현

##### 동작 메커니즘
- 클라이언트의 요청 처리 흐름
  - 클라이언트가 클러스터를 구성하는 캐시 노드 중 하나의 IP 주소에 접속
  - 접근 노드의 레플리카 마스터인 경우 조건 분기
    - 접근 노드가 레플리카인 경우
      - 읽기: 클라이언트 설정에 따라 READONLY 명령어 실행 여붕 ㅔ따라 동작
        - READONLY 명령어가 실행되었고, 해당 키가 슬롯 범위에 있는 경우, 캐시노드에서 요청 처리
        - 그 외, 레디스 서버가 MOVED 리다이렉트로 클라이언트 응답, 클라이언트가 응답을 받고 로컬 슬롯 매핑 업데이트 후 해당 키의 슬롯을 가진 샤드의 마스터에 접근
      - 쓰기: 레디스 서버가 MOVED 리다이렉트로 클라이언트에 응답, 클라이언트가 응답을 받고 로컬 슬롯 매핑 업데이트 후 해당 키의 슬롯을 가진 샤드의 마스터에 접근
    - 접속 노드가 마스터인 경우
      - 키가 해당 노드의 슬롯 범위인 경우 마스터에서 처리
      - 슬롯 밖인 경우 레디스 서버가 MOVED 리다이렉트로 클라이언트에 응답, 클라이언트가 응답을 받고 로컬 슬롯 매핑 업데이트 후 해당 키의 슬롯을 가진 샤드의 마스터에 접근

#### 레디스 클러스터 장애 탐지
- 마스터 노드에 장애나 문제가 발생할 수 있다. 장애 탐지 기능은 이 동작의 수행 시점을 결정
  
##### 장애 탐지 메커니즘
- 레디스 클러스터의 각 캐시 노드의 상태는 PFAIL, FAIL 두가지가 있다
  - 클러스터 내의 노드들은 실뢰할 수 있는 노드에서 다른 노드의 상태 정보를 공유하는 형태로 노드간의 상태 파악
- PFAIL
  - Possible Failure로 특정 노드가 다른 노드에 핑을 보내고 cluster-node-timeout 이내에 응답이 오지 않으면 해당 노드는 로컬 정보에서 핑 대상 노드를 PFAIL 로 표시
  - cluster-node-timeout / 2 만큼 시간이 지나도 핑의 응답이 오지 않으면 연결 재시도
  - 마스터 노드가 PFAIL 상태일 때는 페일오버를 실행할 수 없다.
- FAIL
  - FAIL 상태가 되어야 마스터의 페일오버를 실행할 수 있다.
  - PFAIL에서 다음 조건에 따라 FAIL이 된다.
    - 과반수의 마스터 노드가 대상 노드를 PFAIL, FAIL 상태로 판단하는 경우, 해당 노드는 FAIL 상태가 된다
    - 판단에 걸리는 시간은 cluster-node-timeout * cluster-replica-validaty-factor 로 계산
  - cluster-replica-validaty-factor가 0 이면 연결이 끊어진 시간과 상관없이 마스터-레플리카가 페일오버 실행
    - 레디스 페일오버는 장애가 발생했을 때 레플리카 중 하나를 마스터로 자동 승격시키는 과정
- 레디스 클러스터는 네트워크 장애로 연결이 끊어지면 데이터가 손실될 위험이 있다.
  - 비동기 복제에 따른 손실 가능성
    - Redis 클러스터는 일반적으로 비동기 복제 방식을 사용
    - 새로운 데이터가 마스터에 기록될 때, 복제본(레플리카)으로 즉시 복제되지 않아 마스터가 장애시 데이터 손실 가능
  - 네트워크 분할(파티션) 상황
    - 네트워크 장애로 클러스터가 분할된 경우, 마이너리티 파티션에 클라이언트가 계속 접근하여 데이터를 기록할 수 있다.
    - 레플리카가 마스터로 승격되면, 마이너리티 파티션의 마스터에 기록된 데이터는 클러스터 정상화 과정에서 데이터 손실 가능
  - 페일오버 과정에서의 데이터 유실
    - 자동 페일오버 시, 복제본이 최신 동기화 상태가 아닐 경우 일부 데이터가 손실 가능
    - 레플리카가 마스터로 승격될 때, 마스터와 레플리카 간에 데이터 동기화가 완전히 이루어지지 않았다면 최신 데이터가 복제본에 반영되지 않았을 수 있다.
  - 클러스터 전체 재시작/재배치 시 손실
    - 클러스터의 모든 마스터·슬레이브가 한 번에 재시작되는 경우에도 데이터가 소실될 수 있다.
    - 특히 디스크 영속화(RDB, AOF)가 활성화되어 있지 않거나, 종료 과정/복구 과정에서 데이터 파일이 손상되면 메모리에 있던 데이터 전체가 사라질 수 있다.
  - 방지 및 완화 방법
    - 동기 복제 사용: WAIT 명령어를 이용해 동기 복제를 적용하면 손실 가능성을 줄일 수 있으나, 성능 저하를 감수해야 한다.
    - 데이터 영속화(RDB, AOF) 활성화: 주기적 데이터 스냅샷 및 Append Only File을 활용하여 장애가 생기더라도 데이터를 복구할 수 있도록 설계
    - 수동 페일오버: 계획된 페일오버에서는 데이터가 복제본에 안전하게 동기화된 후 승격이 이루어져 데이터 손실 위험이 낮아진다.
    - 모니터링 및 백업: Redis 모니터링 시스템 도입과 외부 백업(RDB/AOF 파일의 클라우드 백업 등)으로 장애 시 추가적인 복구 경로 확보가 필요

##### 레플리카 선출
- 장애 감지 및 페일오버 시작
  - 마스터 노드가 FAIL 상태로 감지되면, 같은 샤드 내 레플리카들은 일정한 대기 시간을 두고 동시 선거 방지 준비
  - 딜레이 공식: DELAY = 500ms + random(0~500ms) + REPLICA_RANK*1000ms
  - 가장 최신의 레플리케이션 오프셋(=마스터와 가장 가깝게 동기화된 레플리카)이 빠르게 응답하여 우선 선거를 시작
- 레플리카의 선거 요청
  - 레플리카가 마스터 승격을 원하면 클러스터의 모든 마스터 노드에 FAILOVER_AUTH_REQUEST 패킷(투표 요청) 브로드캐스팅
- 투표 및 과반수 획득
  - 다른 마스터 노드들은 느낌표가 FAIL 상태임을 확인하고, 해당 레플리카 요청에 대해 투표(ACK)를 부여합니다.
  - 레플리카가 마스터의 과반수에게 투표를 받아야 승격 가능
  - 투표 미달 시 일정 시간(최소2초) 후 재시도
- 승격 및 역할 변경
  - 과반수 투표(AUTH ACK)를 받은 레플리카가 마스터로 승계되며, 유니크한 새로운 configEpoch 값을 갖게 된다.
  - 승격된 레플리카는 자신의 역할을 마스터로 알리기 시작하며, 다른 노드는 해당 정보에 따라 동작을 변경합니다.
- 최적화 및 재구성
  - 가장 최신의 레플리카(Replication Offset 순위 0)가 우선 승격될 확률이 높으며, 실패 시 다음 후보 재시도
  - 장애 전 마스터는 복구 후 자동으로 레플리카 역할로 전환

#### 레디스 클러스터 키워드

#### 레디스 클러스터 지원 클라이언트

#### 레디스 클러스터 관련 명령어
