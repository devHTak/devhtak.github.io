### 서비스 환경에 대한 고려

#### 모니터링
- 클러스터 상태 파악
  - EKS 컨트롤 플레인은 AWS를 통해 운영되는 관리형 서비스
  - 데이터 플레인을 EC2로 구축하는 경우 노드를 스스로 관리해야 한다.
    - AWS 오토스케일링 기능을 사용하여 데이터 플레인을 구축하고 최소 서버 대수를 설정하면 그 아래로 떨어지지 않도록 AWS를 자동으로 관리한다
  - 데이터 플레인 부하상태는 Amazon CloudWatch로 확인할 수 있다.
- CloudWatch의 Container Insights로 애플리케이션 상태 파악
  - Container Insights 기능을 이용하면 클러스터 노드, 파드, 네임스페이스 서비스 레벨의 메트릭을 참조할 수 있다.
    - 노드별로 CloudWatch 에이전트를 데몬셋으로 동작시킨 후 필요한 메트릭을 CloudWatch로 전송
  - 데이터 노드의 IAM 역할에 정책 추가
    - AWA Amazon EC2를 선택해 접속
    - 인스턴스 메뉴를 선택한 후 데이터 노드에 해당하는 인스턴스 ID를 클릭하고 상세 정보 페이지에 IAM 역할 아래 링크 클릭
    - IAM 역할에 정책 연결 버튼 클릭
    - 정책 이름 목록에서 CloudWatchAgentServerPolicy를 선택하여 정책연결 클릭
  - CloudWatch 용 네임스페이스 생성
  - CloudWatch 용 서비스 계정 생성
    - 에이전트 파드가 사용할 서비스 계정 생성 필요
  - CloudWatch 에이전트가 사용할 컨피그맵 생성
    - 에이전트 파드는 컨피그맵을 사용해 각종 설정을 불러오기 때문에 컨피그맵 생성 필요
  - CloudWatch 에이전트를 데몬셋으로 동작시키기
  - Container Insights 에서 수집한 메트릭 확인
- CloudWatch 경보를 이용한 통지
  - 메트릭값에 임계값을 설정하여 Alarm을 생성할 수 있고, 특정 조건으로 통지할 수 있다.

#### 로그 관리와 운영
- 로그 관리 및 운영을 위한 기본 개념
  - 수집: Fluentd 컨테이너를 데몬셋으로 동작시키고 파드의 로그를 CloudWatch Logs에 전송
  - 저장: CloudWatch Logs에 로그를 저장하도록 설정
  - 모니터링: 메트릭 티렉터리를 설정하고 CloudWatch 사용자 메트릭을 생성하여 그 메트릭의 경보를 생성
  - 시각화: CloudWatch의 Logs Insights를 사용하여 대상 로그를 분석하고 CloudWatch의 대시보드로 시각화
- 원래 애플리케이션 로그는 어디에 저장해야 하는가
  - 기존에 WAS 형태는 물리적인 서버에 저장하여 보지만 쿠버네티스 환경에서는 확인하기 어렵다
  - kubectl logs <파드 이름> or kubectl -l app=backend-app과 같은 방법으로 파드의 로그를 참조할 수 있다.
- 로그 수집: EC2에 CloudWatch 에이전트를 설치하고 수집 대상 로그 파일을 설정하면 AWS 로그 저장 공간으로 전송할 있다.
  - 데이터 노드의 IAM 역할에 정책 추가
    - AWA Amazon EC2를 선택해 접속
    - 인스턴스 메뉴를 선택한 후 데이터 노드에 해당하는 인스턴스 ID를 클릭하고 상세 정보 페이지에 IAM 역할 아래 링크 클릭
    - IAM 역할에 정책 연결 버튼 클릭
    - 정책 이름 목록에서 CloudWatchAgentServerPolicy를 선택하여 정책연결 클릭
  - CloudWatch용 네임스페이스 생성
  - 플루언트디 컨테이너를 데몬셋으로 동작시키기
- 로그 저장
  - 기본적으로 기간 제한 없이 저장되며 로그 용량에 따라 과금 발생
  - CloudWatch Logs 보관 기간 설정 필요
    - 로그 그룹 단위로 로그 저장 기간을 설정할 수 있다.
    - application, host, dataplane 단위로 설정할 수 있다.
- 로그 모니터링
  - CloudWatch 경보를 사용한 통지
    - 에러 로그를 추출하고 CloudWatch 메트릭으로 등록해 경보를 생성하면 통지를 보낼 수 있다.
      - 매트릭 필터 조건을 'ERROR'로 설정하고 출력 회수를 매트릭에 등록
      - 출력 회수 매트릭 통보 생성(5분간 1회 이상 발생하면 통지 등)
    - 매트릭 필터에 애플리케이션을 별도로 설정할 수 있다.
      - 이 방법은 사용자 매트릭이 증가하여 비용이 추가 발생한다.
- 로그의 시각화와 분석
  - CloudWatch Logs에 저장된 로그를 검색하고 시각화하는 기능은 CloudWatch Logs Insights 제공

#### 오토스케일링
- 오토스케일링: 시스템 부하 상황에 따라 자동으로 리소스를 유연하게 조정하는 것
- Cluster Autoscaler를 이용한 데이터 플레인 오토시케일링
  - Cluster Autoscaler를 이용한 발견적 오토스케일링
    - 스케일링 트리거 기준은 파드에 설정된 리소스 요청에 따라 판단
      - 새로운 파드를 요청할 때 요청한 CPU 리소스와 메모리 크기에 여유가 없다면 파드는 Pending 상태
      - Cluster Autoscaler는 해당 상황을 감지하고 파드가 동작할 수 있도록 노드를 추가한다.
    - 설정 방법
      - IAM 역할에 AutoScalingFullAccess 정책 연결 필요
      - EC2 Auto Scaling 그룹을 선택하여 Auto Scaling 그룹 이름을 spec.template.spec.containers.command와 .env 설정 추가
  - Cluster Autoscaler 주의할 점
    - POD의 requests 값으로 스케일링 되기 때문에 부하가 작지만 requests값이 큰경우 스케일링 될 수 있다.
    - requests는 작지만 limits가 높아 부하가 발생했을 때 requests 자체에 리소스가 여유있다고 판단되어 노드에 과부하 상태가 될 수 있다.
  - AWS 오토스케일링 기능을 이용한 예방적 오토스케일링
    - 리소스가 부족하여 파드가 배치할 수 없는 상황에 스케일링 진행된다는 건 어떤 문제가 발생했을 때 대처하는 것
    - 노드에 대한 POD의 CPU 사욜률(pod_cpu_reserved_capacity)를 사용하여 스케일링을 하면 노드에 과부하를 주는 것을 예방할 수 있다.
- Horizontal Pod Autoscaler를 이용한 파드 오토스케일링
  - HPA는 파드 리소스 사용륭에 맞춰 파드의 스케일 아웃, 인 기능 구현 가능
  - 메트릭 서버 배포
    - HPA는 메트릭 서버를 사용해 현황을 파악한다.
#### 보안
- 클러스터 보안
  - 인증
    - EKS는 IAM 사용하여 인증, 인가 기능 제공
  - 인가
    - 쿠버네티스에서는 Role-Based Access Control 이라는 기능 이용
      - Role과 RoleBinding이란 오브젝트를 사용하여 설정
      - Role 어떤 조작을 허가할 것인 가에 대한 권한셋을 정의하고 RoleBinding은 어떤 사용자에게 어떤 롤을 부여할 것인지 정의
- 노드 보안
  - 파드에 부여하는 호스트 권한 제어
  - 쿠버네티스는 PodSecurityPolicy라는 기능으로 파드에 부여할 권한을 관리한다.
  - 특정 사용자에게 권한 제어를 적용하고 싶다면
    - PodSecurityPolicy를 생성하고 사용한다는 것을 role로 선언하고 role binding으로 role과 사용자를 매핑하면 적용가능
- 파드 보안
  - 컨테이너 라이프 사이클에 맞춘 보안 대책의 필요성
    - 컨테이너 이미지 취약성
      - 컨테이너 내부 소프트웨어를 확인하여 버전 등을 확인하는 부분을 애플리케이션 배포 파이프라인에 포함하여 자동으로 확인할 수 있다.
    - 동작 감시(런타임 보호)
      - 컨테이너가 동작할 때 컨테이너에 문제되는 동작이 실행되는 지 확인
    - 다양한 오픈소스 솔루션 제공
      - 트리비, 마이크로스캐너: 컨테이너 이미지 스캔
      - 팔코: 동작 감시
      - 시스디그, 아쿠아: 오픈소스 소프트웨어를 사용해 자동으로 룰을 업데이트하거나 이상 감지 기능
- 네트워크 보안
  - 네트워크 보안은 크게 두가지 관점으로 생각할 수 있다.
    - 클러스터 외부에서 클러스터 내부로 들어오는 통신에 관한 것
    - 클러스터 내부의 통신에 관한 것
  - 엔드포인트 IP 주소 제한
    - EKS 에서는 엔드포인트의 IP 주소 제한 기능이 있으며 AWS 관리 콘솔에서 설정할 수 있다.
    - 엔드포인트에 대해 보안 그룹과 같은 설정 가능
  - kubectl을 VPC 내부로 제한하는 프라이빗 엔드포인트
    - EKS에서는 프라이빗 엔드포인트를 제공하여 완전히 VPC 내부에서만 접속할 수 있는 클러스터를 생성할 수 있다.
  - 네트워크 정책을 사용한 클러스터 내부 통신 제어
    ```
    apiVersion: v1
    kind: NetworkPolicy
    metadata:
      name: default-deny
      # 적용 대상 네임스페이스 지정
    spec:
      podSelector:
        # 적용 대상 파드 레이블 지정
        matchLabels: {}
      policyTypes:
      - Ingress
      # 수신 규칙 설정
      Ingress:
      - from:
        - podSelector:
            matchLabels:
              app: ServiceB
        ports:
        - protocol: TCP
          port: 80
    ```
    - http 요청만 허가하는 네트워크 정책을 생성하며 파드 label을 사용하여 허용할 파드를 설정할 수 있다.
#### 매니페스트 관리와 CI/CD
- 깃옵스와 깃옵스를 구현하기 위한 도구 등장
  - 쿠버네티스는 모든 설정 정보를 매니페스트라는 YAML 파일로 정의하며 지속적 통합과 지속적 전달을 구현할 수 있다.
  - 깃 옵스 파이프라인 개념
    - 개발자 -> git push -> Git Code -> CI(build/test/push) -> Container Registry -> Config Updater
    - 운영 담당자 -> Git Code(Config Updater 가 이비지 버전 정보 업데이트) -> Deploy Operator -> Kubernetes Cluster 반영
- CodePipeline을 이용해 깃옵스 구현
  - AWS에서 제공하는 CI/CD 서비스로 소스 작성, 빌드, 배포 단계를 정의하고 각종 설정을 수행하여 파이프라인을 구성할 수 있는 서비스
  - CodeCommit에서 제공하는 레포지터리에 푸시하면 파이프라인이 자동 동작해 CodeBuild로 애플리케이션 빌드 진행
  - 컨테이너 이미지를 생성하여 ECR에 푸시하여 컨테이너 이미지를 EKS 자동 배포
- kustomize를 이용한 실정 배포
  - kustomize는 kubectl의 서브 명령어로 kustomize는 동적으로 값을 변경하고 싶다는 요구사항들을 해결해주는 구조를 제공
#### 파게이트
- 데이터 플레인의 가상 머신 운영 및 관리를 AWS에 완전히 맡기는 장점과 가상 머신을 직접 조작할 수 없다는 단점이 있다.
- 파게이트로 파드를 동작시키는 구조
  - 스케줄러에 의해 특정 조건을 기준으로 어떤 노드에 파드를 동작시킬 지 결정
    - 파게이트 프로파일에 설정으로 특정 노드에 파드가 동작할지 조건을 설정할 수 있다.
    - 서브넷, 네임스페이스, 레이블 조건등을 활용
- 파게이트에서 파드와 노드의 관계
  - 파게이트에서는 파드와 노드가 1:1로 동작한다. 즉, 파드가 요구하는 용량에 맞춰 노드가 자동 동작하는 데 파게이트를 사용하면 데이터 플레인 용량 관리에서 해방되어 Cluster Autoscaler를 고려하지 않아도 된다.
- 파게이트 주요 제약 사항
  - 파게이트의 제약 사항이 발생하는 이유는 데이터 플레인이 블랙박스이기 때문에 호스트로의 접속이 제한된 것을 원인이라 생각할 수 있다.
- EKS on Fargate 모니터링과 로그 관리, 운영
  - CloudWatch의 Container Insights와 Logs Insights를 사용하여 모니터링과 로그 관리 구조를 하기 위해서는 데몬셋을 사용하여야 하는 데 파게이트는 데몬셋을 사용할 수 없기 때문에 다른 방식으로 구현해야 한다.
- 네트워크 정책 제한
  - 파게이트는 네트워크 정책도 제한되는 데 EKS에서 네트워크 정책을 사용할 때 칼리고라는 네트워크 정책 에이전트를 사용하는 데 데몬셋을 활용한다.
  - 파드 각각에 사이드카 개념인 엔보이 프록시를 동작시켜 보안 그룹 기능을 구현하는 구조이지만 적절한 해결책은 아니다.
- 파게이트 사용 사례
  - 배치 처리 같이 일시적이거나 정기적으로 많은 리소스를 사용해야 하는 경우
  - 동시에 병렬처리를 하기 위해 많은 파드를 동시에 동작시켜야 하는 경우
